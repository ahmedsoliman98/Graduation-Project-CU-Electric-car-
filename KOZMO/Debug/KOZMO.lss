
KOZMO.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000168c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  0000168c  00001720  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000019  0080007c  0080007c  0000173c  2**0
                  ALLOC
  3 .stab         00002100  00000000  00000000  0000173c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000646  00000000  00000000  0000383c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00003e88  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d95  00000000  00000000  00003fc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000782  00000000  00000000  00005d5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b5e  00000000  00000000  000064df  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004c0  00000000  00000000  00007040  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d74  00000000  00000000  00007500  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f34  00000000  00000000  00008274  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  000091a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 8e 05 	jmp	0xb1c	; 0xb1c <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e8       	ldi	r30, 0x8C	; 140
      68:	f6 e1       	ldi	r31, 0x16	; 22
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 39       	cpi	r26, 0x95	; 149
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 55 09 	call	0x12aa	; 0x12aa <main>
      8a:	0c 94 44 0b 	jmp	0x1688	; 0x1688 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Right_Move3>:
		STOP();
	}
	
	void Right_Move3(void)
	{
		motor.MOVMENT = Forward;
      92:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
      96:	20 91 68 00 	lds	r18, 0x0068
      9a:	30 91 69 00 	lds	r19, 0x0069
      9e:	40 91 6a 00 	lds	r20, 0x006A
      a2:	50 91 6b 00 	lds	r21, 0x006B
      a6:	60 91 6c 00 	lds	r22, 0x006C
      aa:	70 91 6d 00 	lds	r23, 0x006D
      ae:	80 91 6e 00 	lds	r24, 0x006E
      b2:	90 e0       	ldi	r25, 0x00	; 0
      b4:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 255);
      b8:	60 91 64 00 	lds	r22, 0x0064
      bc:	70 91 65 00 	lds	r23, 0x0065
      c0:	80 91 66 00 	lds	r24, 0x0066
      c4:	90 91 67 00 	lds	r25, 0x0067
      c8:	4f ef       	ldi	r20, 0xFF	; 255
      ca:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 50);
      ce:	60 91 60 00 	lds	r22, 0x0060
      d2:	70 91 61 00 	lds	r23, 0x0061
      d6:	80 91 62 00 	lds	r24, 0x0062
      da:	90 91 63 00 	lds	r25, 0x0063
      de:	42 e3       	ldi	r20, 0x32	; 50
      e0:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      e4:	8f ef       	ldi	r24, 0xFF	; 255
      e6:	93 e2       	ldi	r25, 0x23	; 35
      e8:	a4 ef       	ldi	r26, 0xF4	; 244
      ea:	81 50       	subi	r24, 0x01	; 1
      ec:	90 40       	sbci	r25, 0x00	; 0
      ee:	a0 40       	sbci	r26, 0x00	; 0
      f0:	e1 f7       	brne	.-8      	; 0xea <Right_Move3+0x58>
      f2:	00 c0       	rjmp	.+0      	; 0xf4 <Right_Move3+0x62>
      f4:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
      f6:	84 e0       	ldi	r24, 0x04	; 4
      f8:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
      fc:	20 91 68 00 	lds	r18, 0x0068
     100:	30 91 69 00 	lds	r19, 0x0069
     104:	40 91 6a 00 	lds	r20, 0x006A
     108:	50 91 6b 00 	lds	r21, 0x006B
     10c:	60 91 6c 00 	lds	r22, 0x006C
     110:	70 91 6d 00 	lds	r23, 0x006D
     114:	80 91 6e 00 	lds	r24, 0x006E
     118:	94 e0       	ldi	r25, 0x04	; 4
     11a:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     11e:	60 91 64 00 	lds	r22, 0x0064
     122:	70 91 65 00 	lds	r23, 0x0065
     126:	80 91 66 00 	lds	r24, 0x0066
     12a:	90 91 67 00 	lds	r25, 0x0067
     12e:	40 e0       	ldi	r20, 0x00	; 0
     130:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     134:	60 91 60 00 	lds	r22, 0x0060
     138:	70 91 61 00 	lds	r23, 0x0061
     13c:	80 91 62 00 	lds	r24, 0x0062
     140:	90 91 63 00 	lds	r25, 0x0063
     144:	40 e0       	ldi	r20, 0x00	; 0
     146:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 255);
		Motor_Speed(EnableB, 50);
		_delay_ms(Delay);
		STOP();
	}
     14a:	08 95       	ret

0000014c <Right_Move2>:
		STOP();
	}
	
	void Right_Move2(void)
	{
		motor.MOVMENT = Forward;
     14c:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     150:	20 91 68 00 	lds	r18, 0x0068
     154:	30 91 69 00 	lds	r19, 0x0069
     158:	40 91 6a 00 	lds	r20, 0x006A
     15c:	50 91 6b 00 	lds	r21, 0x006B
     160:	60 91 6c 00 	lds	r22, 0x006C
     164:	70 91 6d 00 	lds	r23, 0x006D
     168:	80 91 6e 00 	lds	r24, 0x006E
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 255);
     172:	60 91 64 00 	lds	r22, 0x0064
     176:	70 91 65 00 	lds	r23, 0x0065
     17a:	80 91 66 00 	lds	r24, 0x0066
     17e:	90 91 67 00 	lds	r25, 0x0067
     182:	4f ef       	ldi	r20, 0xFF	; 255
     184:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 90);
     188:	60 91 60 00 	lds	r22, 0x0060
     18c:	70 91 61 00 	lds	r23, 0x0061
     190:	80 91 62 00 	lds	r24, 0x0062
     194:	90 91 63 00 	lds	r25, 0x0063
     198:	4a e5       	ldi	r20, 0x5A	; 90
     19a:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	93 e2       	ldi	r25, 0x23	; 35
     1a2:	a4 ef       	ldi	r26, 0xF4	; 244
     1a4:	81 50       	subi	r24, 0x01	; 1
     1a6:	90 40       	sbci	r25, 0x00	; 0
     1a8:	a0 40       	sbci	r26, 0x00	; 0
     1aa:	e1 f7       	brne	.-8      	; 0x1a4 <Right_Move2+0x58>
     1ac:	00 c0       	rjmp	.+0      	; 0x1ae <Right_Move2+0x62>
     1ae:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     1b0:	84 e0       	ldi	r24, 0x04	; 4
     1b2:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     1b6:	20 91 68 00 	lds	r18, 0x0068
     1ba:	30 91 69 00 	lds	r19, 0x0069
     1be:	40 91 6a 00 	lds	r20, 0x006A
     1c2:	50 91 6b 00 	lds	r21, 0x006B
     1c6:	60 91 6c 00 	lds	r22, 0x006C
     1ca:	70 91 6d 00 	lds	r23, 0x006D
     1ce:	80 91 6e 00 	lds	r24, 0x006E
     1d2:	94 e0       	ldi	r25, 0x04	; 4
     1d4:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     1d8:	60 91 64 00 	lds	r22, 0x0064
     1dc:	70 91 65 00 	lds	r23, 0x0065
     1e0:	80 91 66 00 	lds	r24, 0x0066
     1e4:	90 91 67 00 	lds	r25, 0x0067
     1e8:	40 e0       	ldi	r20, 0x00	; 0
     1ea:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     1ee:	60 91 60 00 	lds	r22, 0x0060
     1f2:	70 91 61 00 	lds	r23, 0x0061
     1f6:	80 91 62 00 	lds	r24, 0x0062
     1fa:	90 91 63 00 	lds	r25, 0x0063
     1fe:	40 e0       	ldi	r20, 0x00	; 0
     200:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 255);
		Motor_Speed(EnableB, 90);
		_delay_ms(Delay);
		STOP();
	}
     204:	08 95       	ret

00000206 <Right_Move1>:
		STOP();
	}

	void Right_Move1(void)
	{
		motor.MOVMENT = Forward;
     206:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     20a:	20 91 68 00 	lds	r18, 0x0068
     20e:	30 91 69 00 	lds	r19, 0x0069
     212:	40 91 6a 00 	lds	r20, 0x006A
     216:	50 91 6b 00 	lds	r21, 0x006B
     21a:	60 91 6c 00 	lds	r22, 0x006C
     21e:	70 91 6d 00 	lds	r23, 0x006D
     222:	80 91 6e 00 	lds	r24, 0x006E
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 255);
     22c:	60 91 64 00 	lds	r22, 0x0064
     230:	70 91 65 00 	lds	r23, 0x0065
     234:	80 91 66 00 	lds	r24, 0x0066
     238:	90 91 67 00 	lds	r25, 0x0067
     23c:	4f ef       	ldi	r20, 0xFF	; 255
     23e:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 180);
     242:	60 91 60 00 	lds	r22, 0x0060
     246:	70 91 61 00 	lds	r23, 0x0061
     24a:	80 91 62 00 	lds	r24, 0x0062
     24e:	90 91 63 00 	lds	r25, 0x0063
     252:	44 eb       	ldi	r20, 0xB4	; 180
     254:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     258:	8f ef       	ldi	r24, 0xFF	; 255
     25a:	93 e2       	ldi	r25, 0x23	; 35
     25c:	a4 ef       	ldi	r26, 0xF4	; 244
     25e:	81 50       	subi	r24, 0x01	; 1
     260:	90 40       	sbci	r25, 0x00	; 0
     262:	a0 40       	sbci	r26, 0x00	; 0
     264:	e1 f7       	brne	.-8      	; 0x25e <Right_Move1+0x58>
     266:	00 c0       	rjmp	.+0      	; 0x268 <Right_Move1+0x62>
     268:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     26a:	84 e0       	ldi	r24, 0x04	; 4
     26c:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     270:	20 91 68 00 	lds	r18, 0x0068
     274:	30 91 69 00 	lds	r19, 0x0069
     278:	40 91 6a 00 	lds	r20, 0x006A
     27c:	50 91 6b 00 	lds	r21, 0x006B
     280:	60 91 6c 00 	lds	r22, 0x006C
     284:	70 91 6d 00 	lds	r23, 0x006D
     288:	80 91 6e 00 	lds	r24, 0x006E
     28c:	94 e0       	ldi	r25, 0x04	; 4
     28e:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     292:	60 91 64 00 	lds	r22, 0x0064
     296:	70 91 65 00 	lds	r23, 0x0065
     29a:	80 91 66 00 	lds	r24, 0x0066
     29e:	90 91 67 00 	lds	r25, 0x0067
     2a2:	40 e0       	ldi	r20, 0x00	; 0
     2a4:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     2a8:	60 91 60 00 	lds	r22, 0x0060
     2ac:	70 91 61 00 	lds	r23, 0x0061
     2b0:	80 91 62 00 	lds	r24, 0x0062
     2b4:	90 91 63 00 	lds	r25, 0x0063
     2b8:	40 e0       	ldi	r20, 0x00	; 0
     2ba:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 255);
		Motor_Speed(EnableB, 180);
		_delay_ms(Delay);
		STOP();
	}
     2be:	08 95       	ret

000002c0 <Left_Move3>:
		STOP();
	}
	
	void Left_Move3(void)
	{
		motor.MOVMENT = Forward;
     2c0:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     2c4:	20 91 68 00 	lds	r18, 0x0068
     2c8:	30 91 69 00 	lds	r19, 0x0069
     2cc:	40 91 6a 00 	lds	r20, 0x006A
     2d0:	50 91 6b 00 	lds	r21, 0x006B
     2d4:	60 91 6c 00 	lds	r22, 0x006C
     2d8:	70 91 6d 00 	lds	r23, 0x006D
     2dc:	80 91 6e 00 	lds	r24, 0x006E
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 50);
     2e6:	60 91 64 00 	lds	r22, 0x0064
     2ea:	70 91 65 00 	lds	r23, 0x0065
     2ee:	80 91 66 00 	lds	r24, 0x0066
     2f2:	90 91 67 00 	lds	r25, 0x0067
     2f6:	42 e3       	ldi	r20, 0x32	; 50
     2f8:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 255);
     2fc:	60 91 60 00 	lds	r22, 0x0060
     300:	70 91 61 00 	lds	r23, 0x0061
     304:	80 91 62 00 	lds	r24, 0x0062
     308:	90 91 63 00 	lds	r25, 0x0063
     30c:	4f ef       	ldi	r20, 0xFF	; 255
     30e:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     312:	8f ef       	ldi	r24, 0xFF	; 255
     314:	93 e2       	ldi	r25, 0x23	; 35
     316:	a4 ef       	ldi	r26, 0xF4	; 244
     318:	81 50       	subi	r24, 0x01	; 1
     31a:	90 40       	sbci	r25, 0x00	; 0
     31c:	a0 40       	sbci	r26, 0x00	; 0
     31e:	e1 f7       	brne	.-8      	; 0x318 <Left_Move3+0x58>
     320:	00 c0       	rjmp	.+0      	; 0x322 <Left_Move3+0x62>
     322:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     324:	84 e0       	ldi	r24, 0x04	; 4
     326:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     32a:	20 91 68 00 	lds	r18, 0x0068
     32e:	30 91 69 00 	lds	r19, 0x0069
     332:	40 91 6a 00 	lds	r20, 0x006A
     336:	50 91 6b 00 	lds	r21, 0x006B
     33a:	60 91 6c 00 	lds	r22, 0x006C
     33e:	70 91 6d 00 	lds	r23, 0x006D
     342:	80 91 6e 00 	lds	r24, 0x006E
     346:	94 e0       	ldi	r25, 0x04	; 4
     348:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     34c:	60 91 64 00 	lds	r22, 0x0064
     350:	70 91 65 00 	lds	r23, 0x0065
     354:	80 91 66 00 	lds	r24, 0x0066
     358:	90 91 67 00 	lds	r25, 0x0067
     35c:	40 e0       	ldi	r20, 0x00	; 0
     35e:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     362:	60 91 60 00 	lds	r22, 0x0060
     366:	70 91 61 00 	lds	r23, 0x0061
     36a:	80 91 62 00 	lds	r24, 0x0062
     36e:	90 91 63 00 	lds	r25, 0x0063
     372:	40 e0       	ldi	r20, 0x00	; 0
     374:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 50);
		Motor_Speed(EnableB, 255);
		_delay_ms(Delay);
		STOP();
	}
     378:	08 95       	ret

0000037a <Left_Move2>:
		STOP();
	}
	
	void Left_Move2(void)
	{
		motor.MOVMENT = Forward;
     37a:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     37e:	20 91 68 00 	lds	r18, 0x0068
     382:	30 91 69 00 	lds	r19, 0x0069
     386:	40 91 6a 00 	lds	r20, 0x006A
     38a:	50 91 6b 00 	lds	r21, 0x006B
     38e:	60 91 6c 00 	lds	r22, 0x006C
     392:	70 91 6d 00 	lds	r23, 0x006D
     396:	80 91 6e 00 	lds	r24, 0x006E
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 90);
     3a0:	60 91 64 00 	lds	r22, 0x0064
     3a4:	70 91 65 00 	lds	r23, 0x0065
     3a8:	80 91 66 00 	lds	r24, 0x0066
     3ac:	90 91 67 00 	lds	r25, 0x0067
     3b0:	4a e5       	ldi	r20, 0x5A	; 90
     3b2:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 255);
     3b6:	60 91 60 00 	lds	r22, 0x0060
     3ba:	70 91 61 00 	lds	r23, 0x0061
     3be:	80 91 62 00 	lds	r24, 0x0062
     3c2:	90 91 63 00 	lds	r25, 0x0063
     3c6:	4f ef       	ldi	r20, 0xFF	; 255
     3c8:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     3cc:	8f ef       	ldi	r24, 0xFF	; 255
     3ce:	93 e2       	ldi	r25, 0x23	; 35
     3d0:	a4 ef       	ldi	r26, 0xF4	; 244
     3d2:	81 50       	subi	r24, 0x01	; 1
     3d4:	90 40       	sbci	r25, 0x00	; 0
     3d6:	a0 40       	sbci	r26, 0x00	; 0
     3d8:	e1 f7       	brne	.-8      	; 0x3d2 <Left_Move2+0x58>
     3da:	00 c0       	rjmp	.+0      	; 0x3dc <Left_Move2+0x62>
     3dc:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     3de:	84 e0       	ldi	r24, 0x04	; 4
     3e0:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     3e4:	20 91 68 00 	lds	r18, 0x0068
     3e8:	30 91 69 00 	lds	r19, 0x0069
     3ec:	40 91 6a 00 	lds	r20, 0x006A
     3f0:	50 91 6b 00 	lds	r21, 0x006B
     3f4:	60 91 6c 00 	lds	r22, 0x006C
     3f8:	70 91 6d 00 	lds	r23, 0x006D
     3fc:	80 91 6e 00 	lds	r24, 0x006E
     400:	94 e0       	ldi	r25, 0x04	; 4
     402:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     406:	60 91 64 00 	lds	r22, 0x0064
     40a:	70 91 65 00 	lds	r23, 0x0065
     40e:	80 91 66 00 	lds	r24, 0x0066
     412:	90 91 67 00 	lds	r25, 0x0067
     416:	40 e0       	ldi	r20, 0x00	; 0
     418:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     41c:	60 91 60 00 	lds	r22, 0x0060
     420:	70 91 61 00 	lds	r23, 0x0061
     424:	80 91 62 00 	lds	r24, 0x0062
     428:	90 91 63 00 	lds	r25, 0x0063
     42c:	40 e0       	ldi	r20, 0x00	; 0
     42e:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 90);
		Motor_Speed(EnableB, 255);
		_delay_ms(Delay);
		STOP();
	}
     432:	08 95       	ret

00000434 <Left_Move1>:
		STOP();
	}

	void Left_Move1(void)
	{
		motor.MOVMENT = Forward;
     434:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     438:	20 91 68 00 	lds	r18, 0x0068
     43c:	30 91 69 00 	lds	r19, 0x0069
     440:	40 91 6a 00 	lds	r20, 0x006A
     444:	50 91 6b 00 	lds	r21, 0x006B
     448:	60 91 6c 00 	lds	r22, 0x006C
     44c:	70 91 6d 00 	lds	r23, 0x006D
     450:	80 91 6e 00 	lds	r24, 0x006E
     454:	90 e0       	ldi	r25, 0x00	; 0
     456:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 180);
     45a:	60 91 64 00 	lds	r22, 0x0064
     45e:	70 91 65 00 	lds	r23, 0x0065
     462:	80 91 66 00 	lds	r24, 0x0066
     466:	90 91 67 00 	lds	r25, 0x0067
     46a:	44 eb       	ldi	r20, 0xB4	; 180
     46c:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 255);
     470:	60 91 60 00 	lds	r22, 0x0060
     474:	70 91 61 00 	lds	r23, 0x0061
     478:	80 91 62 00 	lds	r24, 0x0062
     47c:	90 91 63 00 	lds	r25, 0x0063
     480:	4f ef       	ldi	r20, 0xFF	; 255
     482:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     486:	8f ef       	ldi	r24, 0xFF	; 255
     488:	93 e2       	ldi	r25, 0x23	; 35
     48a:	a4 ef       	ldi	r26, 0xF4	; 244
     48c:	81 50       	subi	r24, 0x01	; 1
     48e:	90 40       	sbci	r25, 0x00	; 0
     490:	a0 40       	sbci	r26, 0x00	; 0
     492:	e1 f7       	brne	.-8      	; 0x48c <Left_Move1+0x58>
     494:	00 c0       	rjmp	.+0      	; 0x496 <Left_Move1+0x62>
     496:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     498:	84 e0       	ldi	r24, 0x04	; 4
     49a:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     49e:	20 91 68 00 	lds	r18, 0x0068
     4a2:	30 91 69 00 	lds	r19, 0x0069
     4a6:	40 91 6a 00 	lds	r20, 0x006A
     4aa:	50 91 6b 00 	lds	r21, 0x006B
     4ae:	60 91 6c 00 	lds	r22, 0x006C
     4b2:	70 91 6d 00 	lds	r23, 0x006D
     4b6:	80 91 6e 00 	lds	r24, 0x006E
     4ba:	94 e0       	ldi	r25, 0x04	; 4
     4bc:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     4c0:	60 91 64 00 	lds	r22, 0x0064
     4c4:	70 91 65 00 	lds	r23, 0x0065
     4c8:	80 91 66 00 	lds	r24, 0x0066
     4cc:	90 91 67 00 	lds	r25, 0x0067
     4d0:	40 e0       	ldi	r20, 0x00	; 0
     4d2:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     4d6:	60 91 60 00 	lds	r22, 0x0060
     4da:	70 91 61 00 	lds	r23, 0x0061
     4de:	80 91 62 00 	lds	r24, 0x0062
     4e2:	90 91 63 00 	lds	r25, 0x0063
     4e6:	40 e0       	ldi	r20, 0x00	; 0
     4e8:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 180);
		Motor_Speed(EnableB, 255);
		_delay_ms(Delay);
		STOP();
	}
     4ec:	08 95       	ret

000004ee <SectionA_Intit>:
	
  /* Hold The Massage That Was Receive Form Bluetooth */
  unsigned char Bluetooth_Data ;
  
    void SectionA_Intit(void)
	{
     4ee:	af 92       	push	r10
     4f0:	bf 92       	push	r11
     4f2:	cf 92       	push	r12
     4f4:	df 92       	push	r13
     4f6:	ef 92       	push	r14
     4f8:	ff 92       	push	r15
     4fa:	0f 93       	push	r16
     4fc:	1f 93       	push	r17
		
		motor.MOTORNUM = Two_Motor;
     4fe:	10 92 6e 00 	sts	0x006E, r1
		
		USART0.communicationMode = USART_Asyn_DoupleSpeed;
     502:	10 92 83 00 	sts	0x0083, r1
		USART0.communicationTerminal = USART_SingleProcessor;
     506:	10 92 84 00 	sts	0x0084, r1
		USART0.enableMode = USART_TxRx_Enable;
     50a:	e3 e8       	ldi	r30, 0x83	; 131
     50c:	f0 e0       	ldi	r31, 0x00	; 0
     50e:	83 e0       	ldi	r24, 0x03	; 3
     510:	82 93       	st	-Z, r24
		USART0.interruptSource = USART_InterruptsDisable;
     512:	13 82       	std	Z+3, r1	; 0x03
		USART0.dataFrame = USART_8bitData;
     514:	84 83       	std	Z+4, r24	; 0x04
		USART0.frameControl = USART_ParityDisable_1Stop;
     516:	15 82       	std	Z+5, r1	; 0x05
		USART0.baudRate = 9600;
     518:	80 e8       	ldi	r24, 0x80	; 128
     51a:	95 e2       	ldi	r25, 0x25	; 37
     51c:	a0 e0       	ldi	r26, 0x00	; 0
     51e:	b0 e0       	ldi	r27, 0x00	; 0
     520:	80 87       	std	Z+8, r24	; 0x08
     522:	91 87       	std	Z+9, r25	; 0x09
     524:	a2 87       	std	Z+10, r26	; 0x0a
     526:	b3 87       	std	Z+11, r27	; 0x0b
		USART0.errorType = USART_NoError;
     528:	17 82       	std	Z+7, r1	; 0x07

		USART_Intia();
     52a:	0e 94 04 08 	call	0x1008	; 0x1008 <USART_Intia>
		/* This Function Setup the 4 IN pin Of Motor Driver As an Output Pin and The Enable A and Enable B connecting To The Timer And Setup as Phase Correct PWM Inverted Mode */
		MotorDriver_Setup(motor,EnableA, EnableB);
     52e:	e0 90 64 00 	lds	r14, 0x0064
     532:	f0 90 65 00 	lds	r15, 0x0065
     536:	00 91 66 00 	lds	r16, 0x0066
     53a:	10 91 67 00 	lds	r17, 0x0067
     53e:	a0 90 60 00 	lds	r10, 0x0060
     542:	b0 90 61 00 	lds	r11, 0x0061
     546:	c0 90 62 00 	lds	r12, 0x0062
     54a:	d0 90 63 00 	lds	r13, 0x0063
     54e:	20 91 68 00 	lds	r18, 0x0068
     552:	30 91 69 00 	lds	r19, 0x0069
     556:	40 91 6a 00 	lds	r20, 0x006A
     55a:	50 91 6b 00 	lds	r21, 0x006B
     55e:	60 91 6c 00 	lds	r22, 0x006C
     562:	70 91 6d 00 	lds	r23, 0x006D
     566:	80 91 6e 00 	lds	r24, 0x006E
     56a:	90 91 6f 00 	lds	r25, 0x006F
     56e:	0e 94 45 04 	call	0x88a	; 0x88a <MotorDriver_Setup>
	 
	}		
     572:	1f 91       	pop	r17
     574:	0f 91       	pop	r16
     576:	ff 90       	pop	r15
     578:	ef 90       	pop	r14
     57a:	df 90       	pop	r13
     57c:	cf 90       	pop	r12
     57e:	bf 90       	pop	r11
     580:	af 90       	pop	r10
     582:	08 95       	ret

00000584 <SectionA_Operate>:
    void SectionA_Operate(void)
	{
		Bluetooth_Data = USART_ReadByte_Blocking();
     584:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <USART_ReadByte_Blocking>
     588:	80 93 94 00 	sts	0x0094, r24
		
		switch (Bluetooth_Data)
     58c:	84 33       	cpi	r24, 0x34	; 52
     58e:	09 f4       	brne	.+2      	; 0x592 <SectionA_Operate+0xe>
     590:	4d c0       	rjmp	.+154    	; 0x62c <SectionA_Operate+0xa8>
     592:	85 33       	cpi	r24, 0x35	; 53
     594:	b0 f1       	brcs	.+108    	; 0x602 <SectionA_Operate+0x7e>
     596:	86 33       	cpi	r24, 0x36	; 54
     598:	09 f4       	brne	.+2      	; 0x59c <SectionA_Operate+0x18>
     59a:	42 c0       	rjmp	.+132    	; 0x620 <SectionA_Operate+0x9c>
     59c:	86 33       	cpi	r24, 0x36	; 54
     59e:	e8 f1       	brcs	.+122    	; 0x61a <SectionA_Operate+0x96>
     5a0:	82 34       	cpi	r24, 0x42	; 66
     5a2:	09 f4       	brne	.+2      	; 0x5a6 <SectionA_Operate+0x22>
     5a4:	79 c0       	rjmp	.+242    	; 0x698 <SectionA_Operate+0x114>
     5a6:	86 34       	cpi	r24, 0x46	; 70
     5a8:	09 f4       	brne	.+2      	; 0x5ac <SectionA_Operate+0x28>
     5aa:	43 c0       	rjmp	.+134    	; 0x632 <SectionA_Operate+0xae>
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     5ac:	84 e0       	ldi	r24, 0x04	; 4
     5ae:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     5b2:	20 91 68 00 	lds	r18, 0x0068
     5b6:	30 91 69 00 	lds	r19, 0x0069
     5ba:	40 91 6a 00 	lds	r20, 0x006A
     5be:	50 91 6b 00 	lds	r21, 0x006B
     5c2:	60 91 6c 00 	lds	r22, 0x006C
     5c6:	70 91 6d 00 	lds	r23, 0x006D
     5ca:	80 91 6e 00 	lds	r24, 0x006E
     5ce:	94 e0       	ldi	r25, 0x04	; 4
     5d0:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     5d4:	60 91 64 00 	lds	r22, 0x0064
     5d8:	70 91 65 00 	lds	r23, 0x0065
     5dc:	80 91 66 00 	lds	r24, 0x0066
     5e0:	90 91 67 00 	lds	r25, 0x0067
     5e4:	40 e0       	ldi	r20, 0x00	; 0
     5e6:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     5ea:	60 91 60 00 	lds	r22, 0x0060
     5ee:	70 91 61 00 	lds	r23, 0x0061
     5f2:	80 91 62 00 	lds	r24, 0x0062
     5f6:	90 91 63 00 	lds	r25, 0x0063
     5fa:	40 e0       	ldi	r20, 0x00	; 0
     5fc:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     600:	08 95       	ret
	}		
    void SectionA_Operate(void)
	{
		Bluetooth_Data = USART_ReadByte_Blocking();
		
		switch (Bluetooth_Data)
     602:	82 33       	cpi	r24, 0x32	; 50
     604:	81 f0       	breq	.+32     	; 0x626 <SectionA_Operate+0xa2>
     606:	83 33       	cpi	r24, 0x33	; 51
     608:	18 f0       	brcs	.+6      	; 0x610 <SectionA_Operate+0x8c>
			break;
			case '2':
			Left_Move2();
			break;
			case '3':
			Left_Move3();
     60a:	0e 94 60 01 	call	0x2c0	; 0x2c0 <Left_Move3>
			break;
     60e:	08 95       	ret
	}		
    void SectionA_Operate(void)
	{
		Bluetooth_Data = USART_ReadByte_Blocking();
		
		switch (Bluetooth_Data)
     610:	81 33       	cpi	r24, 0x31	; 49
     612:	61 f6       	brne	.-104    	; 0x5ac <SectionA_Operate+0x28>
			break;
			case 'B':
			Back_Move();
			break;
			case '1':
			Left_Move1();
     614:	0e 94 1a 02 	call	0x434	; 0x434 <Left_Move1>
			break;
     618:	08 95       	ret
			break;
			case '4':
			Right_Move1();
			break;
			case '5':
			Right_Move2();
     61a:	0e 94 a6 00 	call	0x14c	; 0x14c <Right_Move2>
			break;
     61e:	08 95       	ret
			case '6':
			Right_Move3();
     620:	0e 94 49 00 	call	0x92	; 0x92 <Right_Move3>
			break;
     624:	08 95       	ret
			break;
			case '1':
			Left_Move1();
			break;
			case '2':
			Left_Move2();
     626:	0e 94 bd 01 	call	0x37a	; 0x37a <Left_Move2>
			break;
     62a:	08 95       	ret
			case '3':
			Left_Move3();
			break;
			case '4':
			Right_Move1();
     62c:	0e 94 03 01 	call	0x206	; 0x206 <Right_Move1>
			break;
     630:	08 95       	ret
	}
	
	
	void Forward_Move(void)
	{
		motor.MOVMENT = Forward;
     632:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     636:	20 91 68 00 	lds	r18, 0x0068
     63a:	30 91 69 00 	lds	r19, 0x0069
     63e:	40 91 6a 00 	lds	r20, 0x006A
     642:	50 91 6b 00 	lds	r21, 0x006B
     646:	60 91 6c 00 	lds	r22, 0x006C
     64a:	70 91 6d 00 	lds	r23, 0x006D
     64e:	80 91 6e 00 	lds	r24, 0x006E
     652:	90 e0       	ldi	r25, 0x00	; 0
	}

	void Back_Move(void)
	{
		motor.MOVMENT = Reverce;
		Motor_Direction(motor);
     654:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 255);
     658:	60 91 64 00 	lds	r22, 0x0064
     65c:	70 91 65 00 	lds	r23, 0x0065
     660:	80 91 66 00 	lds	r24, 0x0066
     664:	90 91 67 00 	lds	r25, 0x0067
     668:	4f ef       	ldi	r20, 0xFF	; 255
     66a:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 255);
     66e:	60 91 60 00 	lds	r22, 0x0060
     672:	70 91 61 00 	lds	r23, 0x0061
     676:	80 91 62 00 	lds	r24, 0x0062
     67a:	90 91 63 00 	lds	r25, 0x0063
     67e:	4f ef       	ldi	r20, 0xFF	; 255
     680:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     684:	8f ef       	ldi	r24, 0xFF	; 255
     686:	93 e2       	ldi	r25, 0x23	; 35
     688:	a4 ef       	ldi	r26, 0xF4	; 244
     68a:	81 50       	subi	r24, 0x01	; 1
     68c:	90 40       	sbci	r25, 0x00	; 0
     68e:	a0 40       	sbci	r26, 0x00	; 0
     690:	e1 f7       	brne	.-8      	; 0x68a <SectionA_Operate+0x106>
     692:	00 c0       	rjmp	.+0      	; 0x694 <SectionA_Operate+0x110>
     694:	00 00       	nop
     696:	8a cf       	rjmp	.-236    	; 0x5ac <SectionA_Operate+0x28>
		STOP();
	}

	void Back_Move(void)
	{
		motor.MOVMENT = Reverce;
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     69e:	20 91 68 00 	lds	r18, 0x0068
     6a2:	30 91 69 00 	lds	r19, 0x0069
     6a6:	40 91 6a 00 	lds	r20, 0x006A
     6aa:	50 91 6b 00 	lds	r21, 0x006B
     6ae:	60 91 6c 00 	lds	r22, 0x006C
     6b2:	70 91 6d 00 	lds	r23, 0x006D
     6b6:	80 91 6e 00 	lds	r24, 0x006E
     6ba:	91 e0       	ldi	r25, 0x01	; 1
     6bc:	cb cf       	rjmp	.-106    	; 0x654 <SectionA_Operate+0xd0>

000006be <Forward_Move>:
	}
	
	
	void Forward_Move(void)
	{
		motor.MOVMENT = Forward;
     6be:	10 92 6f 00 	sts	0x006F, r1
		Motor_Direction(motor);
     6c2:	20 91 68 00 	lds	r18, 0x0068
     6c6:	30 91 69 00 	lds	r19, 0x0069
     6ca:	40 91 6a 00 	lds	r20, 0x006A
     6ce:	50 91 6b 00 	lds	r21, 0x006B
     6d2:	60 91 6c 00 	lds	r22, 0x006C
     6d6:	70 91 6d 00 	lds	r23, 0x006D
     6da:	80 91 6e 00 	lds	r24, 0x006E
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 255);
     6e4:	60 91 64 00 	lds	r22, 0x0064
     6e8:	70 91 65 00 	lds	r23, 0x0065
     6ec:	80 91 66 00 	lds	r24, 0x0066
     6f0:	90 91 67 00 	lds	r25, 0x0067
     6f4:	4f ef       	ldi	r20, 0xFF	; 255
     6f6:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 255);
     6fa:	60 91 60 00 	lds	r22, 0x0060
     6fe:	70 91 61 00 	lds	r23, 0x0061
     702:	80 91 62 00 	lds	r24, 0x0062
     706:	90 91 63 00 	lds	r25, 0x0063
     70a:	4f ef       	ldi	r20, 0xFF	; 255
     70c:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     710:	8f ef       	ldi	r24, 0xFF	; 255
     712:	93 e2       	ldi	r25, 0x23	; 35
     714:	a4 ef       	ldi	r26, 0xF4	; 244
     716:	81 50       	subi	r24, 0x01	; 1
     718:	90 40       	sbci	r25, 0x00	; 0
     71a:	a0 40       	sbci	r26, 0x00	; 0
     71c:	e1 f7       	brne	.-8      	; 0x716 <Forward_Move+0x58>
     71e:	00 c0       	rjmp	.+0      	; 0x720 <Forward_Move+0x62>
     720:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     722:	84 e0       	ldi	r24, 0x04	; 4
     724:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     728:	20 91 68 00 	lds	r18, 0x0068
     72c:	30 91 69 00 	lds	r19, 0x0069
     730:	40 91 6a 00 	lds	r20, 0x006A
     734:	50 91 6b 00 	lds	r21, 0x006B
     738:	60 91 6c 00 	lds	r22, 0x006C
     73c:	70 91 6d 00 	lds	r23, 0x006D
     740:	80 91 6e 00 	lds	r24, 0x006E
     744:	94 e0       	ldi	r25, 0x04	; 4
     746:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     74a:	60 91 64 00 	lds	r22, 0x0064
     74e:	70 91 65 00 	lds	r23, 0x0065
     752:	80 91 66 00 	lds	r24, 0x0066
     756:	90 91 67 00 	lds	r25, 0x0067
     75a:	40 e0       	ldi	r20, 0x00	; 0
     75c:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     760:	60 91 60 00 	lds	r22, 0x0060
     764:	70 91 61 00 	lds	r23, 0x0061
     768:	80 91 62 00 	lds	r24, 0x0062
     76c:	90 91 63 00 	lds	r25, 0x0063
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 255);
		Motor_Speed(EnableB, 255);
		_delay_ms(Delay);
		STOP();
	}
     776:	08 95       	ret

00000778 <Back_Move>:

	void Back_Move(void)
	{
		motor.MOVMENT = Reverce;
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     77e:	20 91 68 00 	lds	r18, 0x0068
     782:	30 91 69 00 	lds	r19, 0x0069
     786:	40 91 6a 00 	lds	r20, 0x006A
     78a:	50 91 6b 00 	lds	r21, 0x006B
     78e:	60 91 6c 00 	lds	r22, 0x006C
     792:	70 91 6d 00 	lds	r23, 0x006D
     796:	80 91 6e 00 	lds	r24, 0x006E
     79a:	91 e0       	ldi	r25, 0x01	; 1
     79c:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 255);
     7a0:	60 91 64 00 	lds	r22, 0x0064
     7a4:	70 91 65 00 	lds	r23, 0x0065
     7a8:	80 91 66 00 	lds	r24, 0x0066
     7ac:	90 91 67 00 	lds	r25, 0x0067
     7b0:	4f ef       	ldi	r20, 0xFF	; 255
     7b2:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 255);
     7b6:	60 91 60 00 	lds	r22, 0x0060
     7ba:	70 91 61 00 	lds	r23, 0x0061
     7be:	80 91 62 00 	lds	r24, 0x0062
     7c2:	90 91 63 00 	lds	r25, 0x0063
     7c6:	4f ef       	ldi	r20, 0xFF	; 255
     7c8:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
     7cc:	8f ef       	ldi	r24, 0xFF	; 255
     7ce:	93 e2       	ldi	r25, 0x23	; 35
     7d0:	a4 ef       	ldi	r26, 0xF4	; 244
     7d2:	81 50       	subi	r24, 0x01	; 1
     7d4:	90 40       	sbci	r25, 0x00	; 0
     7d6:	a0 40       	sbci	r26, 0x00	; 0
     7d8:	e1 f7       	brne	.-8      	; 0x7d2 <Back_Move+0x5a>
     7da:	00 c0       	rjmp	.+0      	; 0x7dc <Back_Move+0x64>
     7dc:	00 00       	nop
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     7de:	84 e0       	ldi	r24, 0x04	; 4
     7e0:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     7e4:	20 91 68 00 	lds	r18, 0x0068
     7e8:	30 91 69 00 	lds	r19, 0x0069
     7ec:	40 91 6a 00 	lds	r20, 0x006A
     7f0:	50 91 6b 00 	lds	r21, 0x006B
     7f4:	60 91 6c 00 	lds	r22, 0x006C
     7f8:	70 91 6d 00 	lds	r23, 0x006D
     7fc:	80 91 6e 00 	lds	r24, 0x006E
     800:	94 e0       	ldi	r25, 0x04	; 4
     802:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     806:	60 91 64 00 	lds	r22, 0x0064
     80a:	70 91 65 00 	lds	r23, 0x0065
     80e:	80 91 66 00 	lds	r24, 0x0066
     812:	90 91 67 00 	lds	r25, 0x0067
     816:	40 e0       	ldi	r20, 0x00	; 0
     818:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     81c:	60 91 60 00 	lds	r22, 0x0060
     820:	70 91 61 00 	lds	r23, 0x0061
     824:	80 91 62 00 	lds	r24, 0x0062
     828:	90 91 63 00 	lds	r25, 0x0063
     82c:	40 e0       	ldi	r20, 0x00	; 0
     82e:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Direction(motor);
		Motor_Speed(EnableA, 255);
		Motor_Speed(EnableB, 255);
		_delay_ms(Delay);
		STOP();
	}
     832:	08 95       	ret

00000834 <STOP>:
		STOP();
	}

	void STOP (void)
	{
		motor.MOVMENT = Stop;
     834:	84 e0       	ldi	r24, 0x04	; 4
     836:	80 93 6f 00 	sts	0x006F, r24
		Motor_Direction(motor);
     83a:	20 91 68 00 	lds	r18, 0x0068
     83e:	30 91 69 00 	lds	r19, 0x0069
     842:	40 91 6a 00 	lds	r20, 0x006A
     846:	50 91 6b 00 	lds	r21, 0x006B
     84a:	60 91 6c 00 	lds	r22, 0x006C
     84e:	70 91 6d 00 	lds	r23, 0x006D
     852:	80 91 6e 00 	lds	r24, 0x006E
     856:	94 e0       	ldi	r25, 0x04	; 4
     858:	0e 94 a6 04 	call	0x94c	; 0x94c <Motor_Direction>
		Motor_Speed(EnableA, 0);
     85c:	60 91 64 00 	lds	r22, 0x0064
     860:	70 91 65 00 	lds	r23, 0x0065
     864:	80 91 66 00 	lds	r24, 0x0066
     868:	90 91 67 00 	lds	r25, 0x0067
     86c:	40 e0       	ldi	r20, 0x00	; 0
     86e:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
		Motor_Speed(EnableB, 0);
     872:	60 91 60 00 	lds	r22, 0x0060
     876:	70 91 61 00 	lds	r23, 0x0061
     87a:	80 91 62 00 	lds	r24, 0x0062
     87e:	90 91 63 00 	lds	r25, 0x0063
     882:	40 e0       	ldi	r20, 0x00	; 0
     884:	0e 94 16 05 	call	0xa2c	; 0xa2c <Motor_Speed>
	}
     888:	08 95       	ret

0000088a <MotorDriver_Setup>:
  
  
  
  
  void MotorDriver_Setup(MotorDriver PINS, TIMER_DATATYPE EN1, TIMER_DATATYPE EN2)
  {
     88a:	4f 92       	push	r4
     88c:	5f 92       	push	r5
     88e:	6f 92       	push	r6
     890:	7f 92       	push	r7
     892:	af 92       	push	r10
     894:	bf 92       	push	r11
     896:	cf 92       	push	r12
     898:	df 92       	push	r13
     89a:	ef 92       	push	r14
     89c:	ff 92       	push	r15
     89e:	0f 93       	push	r16
     8a0:	1f 93       	push	r17
     8a2:	cf 93       	push	r28
     8a4:	df 93       	push	r29
     8a6:	cd b7       	in	r28, 0x3d	; 61
     8a8:	de b7       	in	r29, 0x3e	; 62
     8aa:	28 97       	sbiw	r28, 0x08	; 8
     8ac:	0f b6       	in	r0, 0x3f	; 63
     8ae:	f8 94       	cli
     8b0:	de bf       	out	0x3e, r29	; 62
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	cd bf       	out	0x3d, r28	; 61
     8b6:	29 83       	std	Y+1, r18	; 0x01
     8b8:	3a 83       	std	Y+2, r19	; 0x02
     8ba:	4b 83       	std	Y+3, r20	; 0x03
     8bc:	5c 83       	std	Y+4, r21	; 0x04
     8be:	6d 83       	std	Y+5, r22	; 0x05
     8c0:	7e 83       	std	Y+6, r23	; 0x06
     8c2:	8f 83       	std	Y+7, r24	; 0x07
     8c4:	98 87       	std	Y+8, r25	; 0x08
     8c6:	27 01       	movw	r4, r14
     8c8:	38 01       	movw	r6, r16
     8ca:	76 01       	movw	r14, r12
     8cc:	65 01       	movw	r12, r10
     8ce:	09 81       	ldd	r16, Y+1	; 0x01
     8d0:	1a 81       	ldd	r17, Y+2	; 0x02
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA1,Output);
     8d2:	c8 01       	movw	r24, r16
     8d4:	64 2f       	mov	r22, r20
     8d6:	42 e0       	ldi	r20, 0x02	; 2
     8d8:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA2,Output);
     8dc:	c8 01       	movw	r24, r16
     8de:	6c 81       	ldd	r22, Y+4	; 0x04
     8e0:	42 e0       	ldi	r20, 0x02	; 2
     8e2:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA3,Output);
     8e6:	c8 01       	movw	r24, r16
     8e8:	6d 81       	ldd	r22, Y+5	; 0x05
     8ea:	42 e0       	ldi	r20, 0x02	; 2
     8ec:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA4,Output);
     8f0:	c8 01       	movw	r24, r16
     8f2:	6e 81       	ldd	r22, Y+6	; 0x06
     8f4:	42 e0       	ldi	r20, 0x02	; 2
     8f6:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
	  TIMER_INTIATE(EN1);
     8fa:	c3 01       	movw	r24, r6
     8fc:	b2 01       	movw	r22, r4
     8fe:	0e 94 1d 06 	call	0xc3a	; 0xc3a <TIMER_INTIATE>
	  TIMER_INTIATE(EN2);
     902:	c7 01       	movw	r24, r14
     904:	b6 01       	movw	r22, r12
     906:	0e 94 1d 06 	call	0xc3a	; 0xc3a <TIMER_INTIATE>
	  /* Setup the PWM Signal Get Out From The OCR0,2 as Inverted Mode and the Initial Value of the Compare Match is 0 */
	  TIMER_WAVEGEN_PHACECORRECTPWM(EN1, ClearUp_SetDowen_PCPWM, 0);
     90a:	c3 01       	movw	r24, r6
     90c:	b2 01       	movw	r22, r4
     90e:	46 e0       	ldi	r20, 0x06	; 6
     910:	20 e0       	ldi	r18, 0x00	; 0
     912:	0e 94 49 07 	call	0xe92	; 0xe92 <TIMER_WAVEGEN_PHACECORRECTPWM>
	  TIMER_WAVEGEN_PHACECORRECTPWM(EN2, ClearUp_SetDowen_PCPWM, 0);
     916:	c7 01       	movw	r24, r14
     918:	b6 01       	movw	r22, r12
     91a:	46 e0       	ldi	r20, 0x06	; 6
     91c:	20 e0       	ldi	r18, 0x00	; 0
     91e:	0e 94 49 07 	call	0xe92	; 0xe92 <TIMER_WAVEGEN_PHACECORRECTPWM>
  }
     922:	28 96       	adiw	r28, 0x08	; 8
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	de bf       	out	0x3e, r29	; 62
     92a:	0f be       	out	0x3f, r0	; 63
     92c:	cd bf       	out	0x3d, r28	; 61
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	0f 91       	pop	r16
     936:	ff 90       	pop	r15
     938:	ef 90       	pop	r14
     93a:	df 90       	pop	r13
     93c:	cf 90       	pop	r12
     93e:	bf 90       	pop	r11
     940:	af 90       	pop	r10
     942:	7f 90       	pop	r7
     944:	6f 90       	pop	r6
     946:	5f 90       	pop	r5
     948:	4f 90       	pop	r4
     94a:	08 95       	ret

0000094c <Motor_Direction>:
  
  
  
  void Motor_Direction(MotorDriver motordirection)
  {
     94c:	df 92       	push	r13
     94e:	ef 92       	push	r14
     950:	ff 92       	push	r15
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	cf 93       	push	r28
     958:	df 93       	push	r29
     95a:	cd b7       	in	r28, 0x3d	; 61
     95c:	de b7       	in	r29, 0x3e	; 62
     95e:	28 97       	sbiw	r28, 0x08	; 8
     960:	0f b6       	in	r0, 0x3f	; 63
     962:	f8 94       	cli
     964:	de bf       	out	0x3e, r29	; 62
     966:	0f be       	out	0x3f, r0	; 63
     968:	cd bf       	out	0x3d, r28	; 61
     96a:	29 83       	std	Y+1, r18	; 0x01
     96c:	3a 83       	std	Y+2, r19	; 0x02
     96e:	4b 83       	std	Y+3, r20	; 0x03
     970:	d5 2e       	mov	r13, r21
     972:	5c 83       	std	Y+4, r21	; 0x04
     974:	e6 2e       	mov	r14, r22
     976:	6d 83       	std	Y+5, r22	; 0x05
     978:	f7 2e       	mov	r15, r23
     97a:	7e 83       	std	Y+6, r23	; 0x06
     97c:	8f 83       	std	Y+7, r24	; 0x07
     97e:	98 87       	std	Y+8, r25	; 0x08
     980:	09 81       	ldd	r16, Y+1	; 0x01
     982:	1a 81       	ldd	r17, Y+2	; 0x02
	  switch (motordirection.MOTORNUM)
     984:	88 23       	and	r24, r24
     986:	c1 f4       	brne	.+48     	; 0x9b8 <Motor_Direction+0x6c>
	  {
		  case Two_Motor :
		  /* in This Case Motor A is the Back Motor that give The Main Motion To The Robot And Th Motor B is Direction Motor */
		        switch(motordirection.MOVMENT)
     988:	91 30       	cpi	r25, 0x01	; 1
     98a:	d9 f1       	breq	.+118    	; 0xa02 <Motor_Direction+0xb6>
     98c:	91 30       	cpi	r25, 0x01	; 1
     98e:	10 f5       	brcc	.+68     	; 0x9d4 <Motor_Direction+0x88>
				{
				    case Forward:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
     990:	c8 01       	movw	r24, r16
     992:	64 2f       	mov	r22, r20
     994:	41 e0       	ldi	r20, 0x01	; 1
     996:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
     99a:	c8 01       	movw	r24, r16
     99c:	6d 2d       	mov	r22, r13
     99e:	40 e0       	ldi	r20, 0x00	; 0
     9a0:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
     9a4:	c8 01       	movw	r24, r16
     9a6:	6e 2d       	mov	r22, r14
     9a8:	41 e0       	ldi	r20, 0x01	; 1
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
						 break;
					case Stop:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
     9aa:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
     9ae:	c8 01       	movw	r24, r16
     9b0:	6f 2d       	mov	r22, r15
     9b2:	40 e0       	ldi	r20, 0x00	; 0
     9b4:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
				}	
	      default:
	             /* Handle The Error Function */
	             break;			 				
	  }		  
  }
     9b8:	28 96       	adiw	r28, 0x08	; 8
     9ba:	0f b6       	in	r0, 0x3f	; 63
     9bc:	f8 94       	cli
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	0f be       	out	0x3f, r0	; 63
     9c2:	cd bf       	out	0x3d, r28	; 61
     9c4:	df 91       	pop	r29
     9c6:	cf 91       	pop	r28
     9c8:	1f 91       	pop	r17
     9ca:	0f 91       	pop	r16
     9cc:	ff 90       	pop	r15
     9ce:	ef 90       	pop	r14
     9d0:	df 90       	pop	r13
     9d2:	08 95       	ret
  {
	  switch (motordirection.MOTORNUM)
	  {
		  case Two_Motor :
		  /* in This Case Motor A is the Back Motor that give The Main Motion To The Robot And Th Motor B is Direction Motor */
		        switch(motordirection.MOVMENT)
     9d4:	94 30       	cpi	r25, 0x04	; 4
     9d6:	81 f7       	brne	.-32     	; 0x9b8 <Motor_Direction+0x6c>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
						 break;
					case Stop:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
     9d8:	c8 01       	movw	r24, r16
     9da:	64 2f       	mov	r22, r20
     9dc:	40 e0       	ldi	r20, 0x00	; 0
     9de:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
     9e2:	c8 01       	movw	r24, r16
     9e4:	6d 2d       	mov	r22, r13
     9e6:	40 e0       	ldi	r20, 0x00	; 0
     9e8:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
     9ec:	c8 01       	movw	r24, r16
     9ee:	6e 2d       	mov	r22, r14
     9f0:	40 e0       	ldi	r20, 0x00	; 0
     9f2:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
     9f6:	c8 01       	movw	r24, r16
     9f8:	6f 2d       	mov	r22, r15
     9fa:	40 e0       	ldi	r20, 0x00	; 0
     9fc:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
     a00:	db cf       	rjmp	.-74     	; 0x9b8 <Motor_Direction+0x6c>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
						 break;
					case Reverce:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
     a02:	c8 01       	movw	r24, r16
     a04:	64 2f       	mov	r22, r20
     a06:	40 e0       	ldi	r20, 0x00	; 0
     a08:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
     a0c:	c8 01       	movw	r24, r16
     a0e:	6d 2d       	mov	r22, r13
     a10:	41 e0       	ldi	r20, 0x01	; 1
     a12:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
     a16:	c8 01       	movw	r24, r16
     a18:	6e 2d       	mov	r22, r14
     a1a:	40 e0       	ldi	r20, 0x00	; 0
     a1c:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
     a20:	c8 01       	movw	r24, r16
     a22:	6f 2d       	mov	r22, r15
     a24:	41 e0       	ldi	r20, 0x01	; 1
     a26:	0e 94 55 05 	call	0xaaa	; 0xaaa <DIO_pinWrite>
						 break;
     a2a:	c6 cf       	rjmp	.-116    	; 0x9b8 <Motor_Direction+0x6c>

00000a2c <Motor_Speed>:
  }
  
  
  void Motor_Speed(TIMER_DATATYPE EnableX, char Speed_Value)
  {
	  switch(EnableX.timer_Number)
     a2c:	66 23       	and	r22, r22
     a2e:	11 f4       	brne	.+4      	; 0xa34 <Motor_Speed+0x8>
	  {
		  case Timer0 :
		               OCR0 = Speed_Value ;
     a30:	4c bf       	out	0x3c, r20	; 60
					   break;
     a32:	08 95       	ret
  }
  
  
  void Motor_Speed(TIMER_DATATYPE EnableX, char Speed_Value)
  {
	  switch(EnableX.timer_Number)
     a34:	61 30       	cpi	r22, 0x01	; 1
     a36:	09 f0       	breq	.+2      	; 0xa3a <Motor_Speed+0xe>
     a38:	08 95       	ret
	  {
		  case Timer0 :
		               OCR0 = Speed_Value ;
					   break;
		  case Timer2 :
		              OCR2 = Speed_Value;
     a3a:	43 bd       	out	0x23, r20	; 35
     a3c:	08 95       	ret

00000a3e <DIO_pinConfiguration>:




void DIO_pinConfiguration(GPIO * pinC, pinNumber pin_num, pinMode pin_M)
{
     a3e:	fc 01       	movw	r30, r24
	switch (pin_M)
     a40:	41 30       	cpi	r20, 0x01	; 1
     a42:	19 f1       	breq	.+70     	; 0xa8a <DIO_pinConfiguration+0x4c>
     a44:	41 30       	cpi	r20, 0x01	; 1
     a46:	78 f4       	brcc	.+30     	; 0xa66 <DIO_pinConfiguration+0x28>
		RESET_Bit(pinC -> DDR, pin_num);
		SET_Bit(pinC -> PORT, pin_num);
		break;
		case InputFloat:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) LOW By RESET The Port And Make A Pull down Resistance  */
		RESET_Bit(pinC -> DDR,pin_num);
     a48:	21 81       	ldd	r18, Z+1	; 0x01
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	02 c0       	rjmp	.+4      	; 0xa54 <DIO_pinConfiguration+0x16>
     a50:	88 0f       	add	r24, r24
     a52:	99 1f       	adc	r25, r25
     a54:	6a 95       	dec	r22
     a56:	e2 f7       	brpl	.-8      	; 0xa50 <DIO_pinConfiguration+0x12>
     a58:	80 95       	com	r24
     a5a:	28 23       	and	r18, r24
     a5c:	21 83       	std	Z+1, r18	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
     a5e:	92 81       	ldd	r25, Z+2	; 0x02
     a60:	98 23       	and	r25, r24
     a62:	92 83       	std	Z+2, r25	; 0x02
		break;
     a64:	08 95       	ret



void DIO_pinConfiguration(GPIO * pinC, pinNumber pin_num, pinMode pin_M)
{
	switch (pin_M)
     a66:	42 30       	cpi	r20, 0x02	; 2
     a68:	09 f0       	breq	.+2      	; 0xa6c <DIO_pinConfiguration+0x2e>
     a6a:	08 95       	ret
		RESET_Bit(pinC -> DDR,pin_num);
		RESET_Bit(pinC -> PORT,pin_num);
		break;
		case Output:
		/* In This Case We Make The Pin Output By  SET The DDR And Make It Default State (idle) LOW By Set The Port TO Make It reverse Connection Sink Source to Avoid Error Value When The Number Of The Output Increace */
		SET_Bit(pinC -> DDR, pin_num);
     a6c:	21 81       	ldd	r18, Z+1	; 0x01
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	02 c0       	rjmp	.+4      	; 0xa78 <DIO_pinConfiguration+0x3a>
     a74:	88 0f       	add	r24, r24
     a76:	99 1f       	adc	r25, r25
     a78:	6a 95       	dec	r22
     a7a:	e2 f7       	brpl	.-8      	; 0xa74 <DIO_pinConfiguration+0x36>
     a7c:	28 2b       	or	r18, r24
     a7e:	21 83       	std	Z+1, r18	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
     a80:	92 81       	ldd	r25, Z+2	; 0x02
     a82:	80 95       	com	r24
     a84:	89 23       	and	r24, r25
     a86:	82 83       	std	Z+2, r24	; 0x02
     a88:	08 95       	ret
{
	switch (pin_M)
	{
		case InputPullup:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) HIgh By Set The Port */
		RESET_Bit(pinC -> DDR, pin_num);
     a8a:	21 81       	ldd	r18, Z+1	; 0x01
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	02 c0       	rjmp	.+4      	; 0xa96 <DIO_pinConfiguration+0x58>
     a92:	88 0f       	add	r24, r24
     a94:	99 1f       	adc	r25, r25
     a96:	6a 95       	dec	r22
     a98:	e2 f7       	brpl	.-8      	; 0xa92 <DIO_pinConfiguration+0x54>
     a9a:	98 2f       	mov	r25, r24
     a9c:	90 95       	com	r25
     a9e:	92 23       	and	r25, r18
     aa0:	91 83       	std	Z+1, r25	; 0x01
		SET_Bit(pinC -> PORT, pin_num);
     aa2:	92 81       	ldd	r25, Z+2	; 0x02
     aa4:	98 2b       	or	r25, r24
     aa6:	92 83       	std	Z+2, r25	; 0x02
		break;
     aa8:	08 95       	ret

00000aaa <DIO_pinWrite>:




 void DIO_pinWrite(GPIO * pinC, pinNumber pin_num, DigitalValue state)
 {
     aaa:	fc 01       	movw	r30, r24
	 switch(state)
     aac:	44 23       	and	r20, r20
     aae:	61 f4       	brne	.+24     	; 0xac8 <DIO_pinWrite+0x1e>
		 /* The Pin Get Output High State */
		 SET_Bit(pinC -> PORT, pin_num);
		 break;
		 case LOW:
		 /* The Pin Get Output Low State */
		 RESET_Bit(pinC -> PORT, pin_num);
     ab0:	22 81       	ldd	r18, Z+2	; 0x02
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	02 c0       	rjmp	.+4      	; 0xabc <DIO_pinWrite+0x12>
     ab8:	88 0f       	add	r24, r24
     aba:	99 1f       	adc	r25, r25
     abc:	6a 95       	dec	r22
     abe:	e2 f7       	brpl	.-8      	; 0xab8 <DIO_pinWrite+0xe>
     ac0:	80 95       	com	r24
     ac2:	82 23       	and	r24, r18
     ac4:	82 83       	std	Z+2, r24	; 0x02
     ac6:	08 95       	ret



 void DIO_pinWrite(GPIO * pinC, pinNumber pin_num, DigitalValue state)
 {
	 switch(state)
     ac8:	41 30       	cpi	r20, 0x01	; 1
     aca:	e9 f7       	brne	.-6      	; 0xac6 <DIO_pinWrite+0x1c>
	 {
		 case HIGH:
		 /* The Pin Get Output High State */
		 SET_Bit(pinC -> PORT, pin_num);
     acc:	22 81       	ldd	r18, Z+2	; 0x02
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	02 c0       	rjmp	.+4      	; 0xad8 <DIO_pinWrite+0x2e>
     ad4:	88 0f       	add	r24, r24
     ad6:	99 1f       	adc	r25, r25
     ad8:	6a 95       	dec	r22
     ada:	e2 f7       	brpl	.-8      	; 0xad4 <DIO_pinWrite+0x2a>
     adc:	28 2b       	or	r18, r24
     ade:	22 83       	std	Z+2, r18	; 0x02
		 break;
     ae0:	08 95       	ret

00000ae2 <DIO_pinRead>:
 
 
 DigitalValue DIO_pinRead(GPIO * pinC, pinNumber pin_num)
 {
	 /* This Function Return The Current State Of The Pin by Use The READ_Bit Definition In The Macro Header */
	 return (READ_Bit(pinC -> PIN, pin_num));
     ae2:	fc 01       	movw	r30, r24
     ae4:	20 81       	ld	r18, Z
     ae6:	81 e0       	ldi	r24, 0x01	; 1
     ae8:	90 e0       	ldi	r25, 0x00	; 0
     aea:	06 2e       	mov	r0, r22
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <DIO_pinRead+0x10>
     aee:	88 0f       	add	r24, r24
     af0:	99 1f       	adc	r25, r25
     af2:	0a 94       	dec	r0
     af4:	e2 f7       	brpl	.-8      	; 0xaee <DIO_pinRead+0xc>
     af6:	30 e0       	ldi	r19, 0x00	; 0
     af8:	82 23       	and	r24, r18
     afa:	93 23       	and	r25, r19
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <DIO_pinRead+0x20>
     afe:	95 95       	asr	r25
     b00:	87 95       	ror	r24
     b02:	6a 95       	dec	r22
     b04:	e2 f7       	brpl	.-8      	; 0xafe <DIO_pinRead+0x1c>
 }
     b06:	08 95       	ret

00000b08 <DIO_portConfiguration>:
	  /* We Must Check That THe Value Of The configuration Of The Port Does Not exceed The 8 bit (0 <-> 255) */
	  
	  if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	  {
		  /* The Value On The 8 bit DDR To Define Each Pin From The 8 Pins Of The Port As input Or Output */
		  portC->DDR = portValue;
     b08:	fc 01       	movw	r30, r24
     b0a:	61 83       	std	Z+1, r22	; 0x01
	  }
	  else
	  {
		  //DIO_ErrorIndication()
	  }
  } 
     b0c:	08 95       	ret

00000b0e <DIO_portWrite>:
 {
	  /* We Must Check That THe Value Of The configuration Of The Port Does Not exceed The 8 bit (0 <-> 255) */
	 if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	 {
		 /* Get Out The 8bit Value On The * Pins Of The Port */
		 portC->PORT = portValue;
     b0e:	fc 01       	movw	r30, r24
     b10:	62 83       	std	Z+2, r22	; 0x02
	 }
	 else
	 {
		 //DIO_ErrorIndication()
	 }
 }
     b12:	08 95       	ret

00000b14 <DIO_portRead>:
 
 
 uint8 DIO_portRead(GPIO * portC)
 {
	 /* we And THe Value Of The Port With 1111 1111 And return the result To Get Port State */
	 return (READ_Bit(portC->PORT,ANDINGV_to_readPORT));
     b14:	fc 01       	movw	r30, r24
     b16:	82 81       	ldd	r24, Z+2	; 0x02
	 
 }
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	08 95       	ret

00000b1c <__vector_1>:
  
  
  

  ISR (INT0_vect,ISR_NESTED_ENABLE)
     {
     b1c:	1f 92       	push	r1
     b1e:	0f 92       	push	r0
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	0f 92       	push	r0
     b24:	11 24       	eor	r1, r1
     b26:	2f 93       	push	r18
     b28:	3f 93       	push	r19
     b2a:	4f 93       	push	r20
     b2c:	5f 93       	push	r21
     b2e:	6f 93       	push	r22
     b30:	7f 93       	push	r23
     b32:	8f 93       	push	r24
     b34:	9f 93       	push	r25
     b36:	af 93       	push	r26
     b38:	bf 93       	push	r27
     b3a:	ef 93       	push	r30
     b3c:	ff 93       	push	r31
		 if (EXTINT0_ISR != NULL)
     b3e:	e0 91 80 00 	lds	r30, 0x0080
     b42:	f0 91 81 00 	lds	r31, 0x0081
     b46:	30 97       	sbiw	r30, 0x00	; 0
     b48:	09 f0       	breq	.+2      	; 0xb4c <__vector_1+0x30>
		 {
			 EXTINT0_ISR();
     b4a:	09 95       	icall
		 }
	 }
     b4c:	ff 91       	pop	r31
     b4e:	ef 91       	pop	r30
     b50:	bf 91       	pop	r27
     b52:	af 91       	pop	r26
     b54:	9f 91       	pop	r25
     b56:	8f 91       	pop	r24
     b58:	7f 91       	pop	r23
     b5a:	6f 91       	pop	r22
     b5c:	5f 91       	pop	r21
     b5e:	4f 91       	pop	r20
     b60:	3f 91       	pop	r19
     b62:	2f 91       	pop	r18
     b64:	0f 90       	pop	r0
     b66:	0f be       	out	0x3f, r0	; 63
     b68:	0f 90       	pop	r0
     b6a:	1f 90       	pop	r1
     b6c:	18 95       	reti

00000b6e <EXTINT_InterruptInit>:


	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
     b6e:	81 30       	cpi	r24, 0x01	; 1
     b70:	f9 f0       	breq	.+62     	; 0xbb0 <EXTINT_InterruptInit+0x42>
     b72:	81 30       	cpi	r24, 0x01	; 1
     b74:	78 f4       	brcc	.+30     	; 0xb94 <EXTINT_InterruptInit+0x26>
		{
			case EXINT_INT0 :
				 switch (Mode)
     b76:	61 30       	cpi	r22, 0x01	; 1
     b78:	a1 f1       	breq	.+104    	; 0xbe2 <EXTINT_InterruptInit+0x74>
     b7a:	61 30       	cpi	r22, 0x01	; 1
     b7c:	08 f0       	brcs	.+2      	; 0xb80 <EXTINT_InterruptInit+0x12>
     b7e:	43 c0       	rjmp	.+134    	; 0xc06 <EXTINT_InterruptInit+0x98>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC00);
     b80:	85 b7       	in	r24, 0x35	; 53
     b82:	8e 7f       	andi	r24, 0xFE	; 254
     b84:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     b86:	85 b7       	in	r24, 0x35	; 53
     b88:	8d 7f       	andi	r24, 0xFD	; 253
     b8a:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC00);
						  SET_Bit(MCUCR,ISC01);
						  break;
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
     b8c:	8b b7       	in	r24, 0x3b	; 59
     b8e:	80 64       	ori	r24, 0x40	; 64
     b90:	8b bf       	out	0x3b, r24	; 59
				break;
     b92:	08 95       	ret
	 }


	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
     b94:	82 30       	cpi	r24, 0x02	; 2
     b96:	09 f0       	breq	.+2      	; 0xb9a <EXTINT_InterruptInit+0x2c>
     b98:	08 95       	ret
				 }
				 /* Enable THe InT 0 */
				 SET_Bit(GICR,INT1);
				 break;
		  case EXINT_INT2 :
			   switch (Mode)
     b9a:	62 30       	cpi	r22, 0x02	; 2
     b9c:	b9 f0       	breq	.+46     	; 0xbcc <EXTINT_InterruptInit+0x5e>
     b9e:	63 30       	cpi	r22, 0x03	; 3
     ba0:	19 f4       	brne	.+6      	; 0xba8 <EXTINT_InterruptInit+0x3a>
			   {
				   case EXINT_FallingEdge :
						RESET_Bit(MCUCSR,ISC2);
						break;
				   case EXINT_RisingEdge :
						SET_Bit(MCUCSR,ISC2);
     ba2:	84 b7       	in	r24, 0x34	; 52
     ba4:	80 64       	ori	r24, 0x40	; 64
     ba6:	84 bf       	out	0x34, r24	; 52
				  case EXINT_LowLevel :
				  case EXINT_Toggle :
				  break;
			   }
			   /* Enable THe InT 0 */
			   SET_Bit(GICR,INT2);
     ba8:	8b b7       	in	r24, 0x3b	; 59
     baa:	80 62       	ori	r24, 0x20	; 32
     bac:	8b bf       	out	0x3b, r24	; 59
     bae:	08 95       	ret
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
				break;
		  case EXINT_INT1 :
				 switch (Mode)
     bb0:	61 30       	cpi	r22, 0x01	; 1
     bb2:	81 f0       	breq	.+32     	; 0xbd4 <EXTINT_InterruptInit+0x66>
     bb4:	61 30       	cpi	r22, 0x01	; 1
     bb6:	e0 f4       	brcc	.+56     	; 0xbf0 <EXTINT_InterruptInit+0x82>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC10);
     bb8:	85 b7       	in	r24, 0x35	; 53
     bba:	8b 7f       	andi	r24, 0xFB	; 251
     bbc:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC11);
     bbe:	85 b7       	in	r24, 0x35	; 53
     bc0:	87 7f       	andi	r24, 0xF7	; 247
     bc2:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC11);
						  SET_Bit(MCUCR,ISC10);
					break;
				 }
				 /* Enable THe InT 0 */
				 SET_Bit(GICR,INT1);
     bc4:	8b b7       	in	r24, 0x3b	; 59
     bc6:	80 68       	ori	r24, 0x80	; 128
     bc8:	8b bf       	out	0x3b, r24	; 59
				 break;
     bca:	08 95       	ret
		  case EXINT_INT2 :
			   switch (Mode)
			   {
				   case EXINT_FallingEdge :
						RESET_Bit(MCUCSR,ISC2);
     bcc:	84 b7       	in	r24, 0x34	; 52
     bce:	8f 7b       	andi	r24, 0xBF	; 191
     bd0:	84 bf       	out	0x34, r24	; 52
						break;
     bd2:	ea cf       	rjmp	.-44     	; 0xba8 <EXTINT_InterruptInit+0x3a>
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC10);
						  RESET_Bit(MCUCR,ISC11);
						  break;
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC11);
     bd4:	85 b7       	in	r24, 0x35	; 53
     bd6:	88 60       	ori	r24, 0x08	; 8
     bd8:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC10);
     bda:	85 b7       	in	r24, 0x35	; 53
     bdc:	8b 7f       	andi	r24, 0xFB	; 251
     bde:	85 bf       	out	0x35, r24	; 53
						  break;
     be0:	f1 cf       	rjmp	.-30     	; 0xbc4 <EXTINT_InterruptInit+0x56>
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC00);
						  RESET_Bit(MCUCR,ISC01);
						  break;
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC00);
     be2:	85 b7       	in	r24, 0x35	; 53
     be4:	81 60       	ori	r24, 0x01	; 1
     be6:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     be8:	85 b7       	in	r24, 0x35	; 53
     bea:	8d 7f       	andi	r24, 0xFD	; 253
     bec:	85 bf       	out	0x35, r24	; 53
						  break;
     bee:	ce cf       	rjmp	.-100    	; 0xb8c <EXTINT_InterruptInit+0x1e>
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
				break;
		  case EXINT_INT1 :
				 switch (Mode)
     bf0:	62 30       	cpi	r22, 0x02	; 2
     bf2:	e1 f0       	breq	.+56     	; 0xc2c <EXTINT_InterruptInit+0xbe>
     bf4:	63 30       	cpi	r22, 0x03	; 3
     bf6:	31 f7       	brne	.-52     	; 0xbc4 <EXTINT_InterruptInit+0x56>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC11);
						  SET_Bit(MCUCR,ISC10);
						  break;
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC11);
     bf8:	85 b7       	in	r24, 0x35	; 53
     bfa:	88 60       	ori	r24, 0x08	; 8
     bfc:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     bfe:	85 b7       	in	r24, 0x35	; 53
     c00:	84 60       	ori	r24, 0x04	; 4
     c02:	85 bf       	out	0x35, r24	; 53
					break;
     c04:	df cf       	rjmp	.-66     	; 0xbc4 <EXTINT_InterruptInit+0x56>
	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
		{
			case EXINT_INT0 :
				 switch (Mode)
     c06:	62 30       	cpi	r22, 0x02	; 2
     c08:	51 f0       	breq	.+20     	; 0xc1e <EXTINT_InterruptInit+0xb0>
     c0a:	63 30       	cpi	r22, 0x03	; 3
     c0c:	09 f0       	breq	.+2      	; 0xc10 <EXTINT_InterruptInit+0xa2>
     c0e:	be cf       	rjmp	.-132    	; 0xb8c <EXTINT_InterruptInit+0x1e>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC00);
						  SET_Bit(MCUCR,ISC01);
						  break;
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC00);
     c10:	85 b7       	in	r24, 0x35	; 53
     c12:	81 60       	ori	r24, 0x01	; 1
     c14:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     c16:	85 b7       	in	r24, 0x35	; 53
     c18:	82 60       	ori	r24, 0x02	; 2
     c1a:	85 bf       	out	0x35, r24	; 53
						  break;
     c1c:	b7 cf       	rjmp	.-146    	; 0xb8c <EXTINT_InterruptInit+0x1e>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC00);
						  RESET_Bit(MCUCR,ISC01);
						  break;
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC00);
     c1e:	85 b7       	in	r24, 0x35	; 53
     c20:	8e 7f       	andi	r24, 0xFE	; 254
     c22:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     c24:	85 b7       	in	r24, 0x35	; 53
     c26:	82 60       	ori	r24, 0x02	; 2
     c28:	85 bf       	out	0x35, r24	; 53
						  break;
     c2a:	b0 cf       	rjmp	.-160    	; 0xb8c <EXTINT_InterruptInit+0x1e>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC11);
						  RESET_Bit(MCUCR,ISC10);
						  break;
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC11);
     c2c:	85 b7       	in	r24, 0x35	; 53
     c2e:	87 7f       	andi	r24, 0xF7	; 247
     c30:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     c32:	85 b7       	in	r24, 0x35	; 53
     c34:	84 60       	ori	r24, 0x04	; 4
     c36:	85 bf       	out	0x35, r24	; 53
						  break;
     c38:	c5 cf       	rjmp	.-118    	; 0xbc4 <EXTINT_InterruptInit+0x56>

00000c3a <TIMER_INTIATE>:
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     c3a:	66 23       	and	r22, r22
     c3c:	e9 f4       	brne	.+58     	; 0xc78 <TIMER_INTIATE+0x3e>
     c3e:	71 50       	subi	r23, 0x01	; 1
     c40:	74 30       	cpi	r23, 0x04	; 4
     c42:	80 f1       	brcs	.+96     	; 0xca4 <TIMER_INTIATE+0x6a>
     c44:	20 e0       	ldi	r18, 0x00	; 0
					default:
					break;
				}
		
				/* Set Up The Timer Clock Frequency By The Bit CS00, CS01 , CS02 In The TCCR */
				switch(T.timer_CLK)
     c46:	87 30       	cpi	r24, 0x07	; 7
     c48:	09 f4       	brne	.+2      	; 0xc4c <TIMER_INTIATE+0x12>
     c4a:	7d c0       	rjmp	.+250    	; 0xd46 <TIMER_INTIATE+0x10c>
     c4c:	88 30       	cpi	r24, 0x08	; 8
     c4e:	08 f0       	brcs	.+2      	; 0xc52 <TIMER_INTIATE+0x18>
     c50:	4d c0       	rjmp	.+154    	; 0xcec <TIMER_INTIATE+0xb2>
     c52:	83 30       	cpi	r24, 0x03	; 3
     c54:	09 f4       	brne	.+2      	; 0xc58 <TIMER_INTIATE+0x1e>
     c56:	71 c0       	rjmp	.+226    	; 0xd3a <TIMER_INTIATE+0x100>
     c58:	84 30       	cpi	r24, 0x04	; 4
     c5a:	09 f4       	brne	.+2      	; 0xc5e <TIMER_INTIATE+0x24>
     c5c:	6b c0       	rjmp	.+214    	; 0xd34 <TIMER_INTIATE+0xfa>
     c5e:	81 30       	cpi	r24, 0x01	; 1
     c60:	09 f4       	brne	.+2      	; 0xc64 <TIMER_INTIATE+0x2a>
     c62:	60 c0       	rjmp	.+192    	; 0xd24 <TIMER_INTIATE+0xea>
				   default:
				   break;
				}
		
				/* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
				switch(T.TimerINT_Source)
     c64:	91 30       	cpi	r25, 0x01	; 1
     c66:	09 f4       	brne	.+2      	; 0xc6a <TIMER_INTIATE+0x30>
     c68:	4a c0       	rjmp	.+148    	; 0xcfe <TIMER_INTIATE+0xc4>
     c6a:	92 30       	cpi	r25, 0x02	; 2
     c6c:	39 f1       	breq	.+78     	; 0xcbc <TIMER_INTIATE+0x82>
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     c6e:	23 bf       	out	0x33, r18	; 51
			 break;
		}
			
		
		/* Set The I Bit In The Statues Register To Enable The General Interrupt */
		SET_Bit(SREG, 7);
     c70:	8f b7       	in	r24, 0x3f	; 63
     c72:	80 68       	ori	r24, 0x80	; 128
     c74:	8f bf       	out	0x3f, r24	; 63
	}					 
     c76:	08 95       	ret
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     c78:	61 30       	cpi	r22, 0x01	; 1
     c7a:	d1 f7       	brne	.-12     	; 0xc70 <TIMER_INTIATE+0x36>
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
		break;
     c7c:	71 50       	subi	r23, 0x01	; 1
     c7e:	74 30       	cpi	r23, 0x04	; 4
     c80:	b8 f0       	brcs	.+46     	; 0xcb0 <TIMER_INTIATE+0x76>
     c82:	20 e0       	ldi	r18, 0x00	; 0
			     default:
			     break;
		     }
		     
		     /* Set Up The Timer Clock Frequency By The Bit CS20, CS21 , CS22 In The TCCR2 */
		     switch(T.timer_CLK)
     c84:	84 30       	cpi	r24, 0x04	; 4
     c86:	09 f4       	brne	.+2      	; 0xc8a <TIMER_INTIATE+0x50>
     c88:	64 c0       	rjmp	.+200    	; 0xd52 <TIMER_INTIATE+0x118>
     c8a:	85 30       	cpi	r24, 0x05	; 5
     c8c:	e0 f4       	brcc	.+56     	; 0xcc6 <TIMER_INTIATE+0x8c>
     c8e:	82 30       	cpi	r24, 0x02	; 2
     c90:	09 f4       	brne	.+2      	; 0xc94 <TIMER_INTIATE+0x5a>
     c92:	65 c0       	rjmp	.+202    	; 0xd5e <TIMER_INTIATE+0x124>
     c94:	83 30       	cpi	r24, 0x03	; 3
     c96:	08 f0       	brcs	.+2      	; 0xc9a <TIMER_INTIATE+0x60>
     c98:	42 c0       	rjmp	.+132    	; 0xd1e <TIMER_INTIATE+0xe4>
     c9a:	81 30       	cpi	r24, 0x01	; 1
     c9c:	f1 f4       	brne	.+60     	; 0xcda <TIMER_INTIATE+0xa0>
		     {
			     case Timer_NoCLK_Source:
			     /* It SI The Default State At All Bit Equal 0 */
			     break;
			     case Timer_Fcpu:
			     SET_Bit(TCCR_Temp,CS20);
     c9e:	21 60       	ori	r18, 0x01	; 1
			     RESET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
     ca0:	29 7f       	andi	r18, 0xF9	; 249
			     break;
     ca2:	1b c0       	rjmp	.+54     	; 0xcda <TIMER_INTIATE+0xa0>
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     ca4:	e7 2f       	mov	r30, r23
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	e0 59       	subi	r30, 0x90	; 144
     caa:	ff 4f       	sbci	r31, 0xFF	; 255
     cac:	20 81       	ld	r18, Z
     cae:	cb cf       	rjmp	.-106    	; 0xc46 <TIMER_INTIATE+0xc>
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
		break;
     cb0:	e7 2f       	mov	r30, r23
     cb2:	f0 e0       	ldi	r31, 0x00	; 0
     cb4:	ec 58       	subi	r30, 0x8C	; 140
     cb6:	ff 4f       	sbci	r31, 0xFF	; 255
     cb8:	20 81       	ld	r18, Z
     cba:	e4 cf       	rjmp	.-56     	; 0xc84 <TIMER_INTIATE+0x4a>
						 /* This Interrupt happened when the TCNT reach its Max then return to zero again */ 
						 SET_Bit(TIMSK,TOIE0);
					break;
					case Timer_TopCTC_Interrupt:
						 /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
						 SET_Bit(TIMSK,OCIE0);
     cbc:	89 b7       	in	r24, 0x39	; 57
     cbe:	82 60       	ori	r24, 0x02	; 2
     cc0:	89 bf       	out	0x39, r24	; 57
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     cc2:	23 bf       	out	0x33, r18	; 51
     cc4:	d5 cf       	rjmp	.-86     	; 0xc70 <TIMER_INTIATE+0x36>
			     default:
			     break;
		     }
		     
		     /* Set Up The Timer Clock Frequency By The Bit CS20, CS21 , CS22 In The TCCR2 */
		     switch(T.timer_CLK)
     cc6:	86 30       	cpi	r24, 0x06	; 6
     cc8:	09 f4       	brne	.+2      	; 0xccc <TIMER_INTIATE+0x92>
     cca:	46 c0       	rjmp	.+140    	; 0xd58 <TIMER_INTIATE+0x11e>
     ccc:	86 30       	cpi	r24, 0x06	; 6
     cce:	20 f1       	brcs	.+72     	; 0xd18 <TIMER_INTIATE+0xde>
     cd0:	87 30       	cpi	r24, 0x07	; 7
     cd2:	e1 f1       	breq	.+120    	; 0xd4c <TIMER_INTIATE+0x112>
     cd4:	88 30       	cpi	r24, 0x08	; 8
     cd6:	09 f4       	brne	.+2      	; 0xcda <TIMER_INTIATE+0xa0>
			     SET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div1024:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     cd8:	27 60       	ori	r18, 0x07	; 7
				 /* If The User Select Else This Cases Handle An Error Massage */
			     break;
		     }
		     
		     /* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
		     switch(T.TimerINT_Source)
     cda:	91 30       	cpi	r25, 0x01	; 1
     cdc:	31 f1       	breq	.+76     	; 0xd2a <TIMER_INTIATE+0xf0>
     cde:	92 30       	cpi	r25, 0x02	; 2
     ce0:	99 f0       	breq	.+38     	; 0xd08 <TIMER_INTIATE+0xce>
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     ce2:	25 bd       	out	0x25, r18	; 37
			 break;
		}
			
		
		/* Set The I Bit In The Statues Register To Enable The General Interrupt */
		SET_Bit(SREG, 7);
     ce4:	8f b7       	in	r24, 0x3f	; 63
     ce6:	80 68       	ori	r24, 0x80	; 128
     ce8:	8f bf       	out	0x3f, r24	; 63
	}					 
     cea:	08 95       	ret
					default:
					break;
				}
		
				/* Set Up The Timer Clock Frequency By The Bit CS00, CS01 , CS02 In The TCCR */
				switch(T.timer_CLK)
     cec:	89 30       	cpi	r24, 0x09	; 9
     cee:	41 f1       	breq	.+80     	; 0xd40 <TIMER_INTIATE+0x106>
     cf0:	89 30       	cpi	r24, 0x09	; 9
     cf2:	78 f0       	brcs	.+30     	; 0xd12 <TIMER_INTIATE+0xd8>
     cf4:	8a 30       	cpi	r24, 0x0A	; 10
     cf6:	09 f0       	breq	.+2      	; 0xcfa <TIMER_INTIATE+0xc0>
     cf8:	b5 cf       	rjmp	.-150    	; 0xc64 <TIMER_INTIATE+0x2a>
						 SET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_RisingEdge:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     cfa:	27 60       	ori	r18, 0x07	; 7
				   break;
     cfc:	b3 cf       	rjmp	.-154    	; 0xc64 <TIMER_INTIATE+0x2a>
				/* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
				switch(T.TimerINT_Source)
				{
					case Timer_Overflow_Interrupt:
						 /* This Interrupt happened when the TCNT reach its Max then return to zero again */ 
						 SET_Bit(TIMSK,TOIE0);
     cfe:	89 b7       	in	r24, 0x39	; 57
     d00:	81 60       	ori	r24, 0x01	; 1
     d02:	89 bf       	out	0x39, r24	; 57
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     d04:	23 bf       	out	0x33, r18	; 51
     d06:	b4 cf       	rjmp	.-152    	; 0xc70 <TIMER_INTIATE+0x36>
			     /* This Interrupt happened when the TCNT reach its Max then return to zero again */
			     SET_Bit(TIMSK,TOIE2);
			     break;
			     case Timer_TopCTC_Interrupt:
			     /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
			     SET_Bit(TIMSK,OCIE2);
     d08:	89 b7       	in	r24, 0x39	; 57
     d0a:	80 68       	ori	r24, 0x80	; 128
     d0c:	89 bf       	out	0x39, r24	; 57
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     d0e:	25 bd       	out	0x25, r18	; 37
     d10:	e9 cf       	rjmp	.-46     	; 0xce4 <TIMER_INTIATE+0xaa>
						 RESET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div1024:
						 SET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     d12:	28 7f       	andi	r18, 0xF8	; 248
						 SET_Bit(TCCR_Temp,CS02);
     d14:	25 60       	ori	r18, 0x05	; 5
					break;
     d16:	a6 cf       	rjmp	.-180    	; 0xc64 <TIMER_INTIATE+0x2a>
			     SET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div32:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     d18:	23 60       	ori	r18, 0x03	; 3
			     RESET_Bit(TCCR_Temp,CS22);
     d1a:	2b 7f       	andi	r18, 0xFB	; 251
			     break;
     d1c:	de cf       	rjmp	.-68     	; 0xcda <TIMER_INTIATE+0xa0>
					  RESET_Bit(TCCR_Temp,CS21);
					  SET_Bit(TCCR_Temp,CS22);
				 break;
			     case Timer_Fcpu_Div8:
			     RESET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     d1e:	28 7f       	andi	r18, 0xF8	; 248
			     RESET_Bit(TCCR_Temp,CS22);
     d20:	22 60       	ori	r18, 0x02	; 2
			     break;
     d22:	db cf       	rjmp	.-74     	; 0xcda <TIMER_INTIATE+0xa0>
					case Timer_NoCLK_Source:
						/* It SI The Default State At All Bit Equal 0 */
						/* In This Case The Timer Gets Its Clock From External Device */
					break;
					case Timer_Fcpu:
						 SET_Bit(TCCR_Temp,CS00);
     d24:	21 60       	ori	r18, 0x01	; 1
						 RESET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
     d26:	29 7f       	andi	r18, 0xF9	; 249
					break;
     d28:	9d cf       	rjmp	.-198    	; 0xc64 <TIMER_INTIATE+0x2a>
		     /* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
		     switch(T.TimerINT_Source)
		     {
			     case Timer_Overflow_Interrupt:
			     /* This Interrupt happened when the TCNT reach its Max then return to zero again */
			     SET_Bit(TIMSK,TOIE2);
     d2a:	89 b7       	in	r24, 0x39	; 57
     d2c:	80 64       	ori	r24, 0x40	; 64
     d2e:	89 bf       	out	0x39, r24	; 57
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     d30:	25 bd       	out	0x25, r18	; 37
     d32:	d8 cf       	rjmp	.-80     	; 0xce4 <TIMER_INTIATE+0xaa>
						 SET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div64:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     d34:	23 60       	ori	r18, 0x03	; 3
						 RESET_Bit(TCCR_Temp,CS02);
     d36:	2b 7f       	andi	r18, 0xFB	; 251
					break;
     d38:	95 cf       	rjmp	.-214    	; 0xc64 <TIMER_INTIATE+0x2a>
						 RESET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div8:
						 RESET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     d3a:	28 7f       	andi	r18, 0xF8	; 248
						 RESET_Bit(TCCR_Temp,CS02);
     d3c:	22 60       	ori	r18, 0x02	; 2
					break;
     d3e:	92 cf       	rjmp	.-220    	; 0xc64 <TIMER_INTIATE+0x2a>
						 SET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_FallingEdge:
						 RESET_Bit(TCCR_Temp,CS00);
     d40:	2e 7f       	andi	r18, 0xFE	; 254
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     d42:	26 60       	ori	r18, 0x06	; 6
					break;
     d44:	8f cf       	rjmp	.-226    	; 0xc64 <TIMER_INTIATE+0x2a>
						 SET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div256:
						 RESET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     d46:	2c 7f       	andi	r18, 0xFC	; 252
						 SET_Bit(TCCR_Temp,CS02);
     d48:	24 60       	ori	r18, 0x04	; 4
					break;
     d4a:	8c cf       	rjmp	.-232    	; 0xc64 <TIMER_INTIATE+0x2a>
			     SET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div256:
			     RESET_Bit(TCCR_Temp,CS20);
     d4c:	2e 7f       	andi	r18, 0xFE	; 254
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     d4e:	26 60       	ori	r18, 0x06	; 6
			     break;
     d50:	c4 cf       	rjmp	.-120    	; 0xcda <TIMER_INTIATE+0xa0>
			     SET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div64:
			     RESET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     d52:	2c 7f       	andi	r18, 0xFC	; 252
			     SET_Bit(TCCR_Temp,CS22);
     d54:	24 60       	ori	r18, 0x04	; 4
			     break;
     d56:	c1 cf       	rjmp	.-126    	; 0xcda <TIMER_INTIATE+0xa0>
			     case Timer_Fcpu_Div128:
			     SET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     d58:	28 7f       	andi	r18, 0xF8	; 248
			     SET_Bit(TCCR_Temp,CS22);
     d5a:	25 60       	ori	r18, 0x05	; 5
			     break;
     d5c:	be cf       	rjmp	.-132    	; 0xcda <TIMER_INTIATE+0xa0>
				 case Timer2_OneSec_CLK:
				      /* In This Case To Get The Clock Exactly At One Sec We Used An External Clock With Value 32768Hz At Timer 2 Only Connect To the Pin 6 & 7 at Port C 
					   * Set the Pin AS2 At The Register ASSR To Make The Clock Source From The External Crystal 
					   *  Prescaler Value Will Used is 128 So 
					   */
					  ASSR = 0x08;
     d5e:	88 e0       	ldi	r24, 0x08	; 8
     d60:	82 bd       	out	0x22, r24	; 34
					  SET_Bit(TCCR_Temp,CS20);
					  RESET_Bit(TCCR_Temp,CS21);
     d62:	28 7f       	andi	r18, 0xF8	; 248
					  SET_Bit(TCCR_Temp,CS22);
     d64:	25 60       	ori	r18, 0x05	; 5
				 break;
     d66:	b9 cf       	rjmp	.-142    	; 0xcda <TIMER_INTIATE+0xa0>

00000d68 <TIMER_DELAY>:

	
		
    void TIMER_DELAY(TIMER_DATATYPE t, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     d68:	66 23       	and	r22, r22
     d6a:	11 f4       	brne	.+4      	; 0xd70 <TIMER_DELAY+0x8>
		{
			case Timer0: 
			     OCR0 = Top_Value;
     d6c:	4c bf       	out	0x3c, r20	; 60
			break;
     d6e:	08 95       	ret

	
		
    void TIMER_DELAY(TIMER_DATATYPE t, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     d70:	61 30       	cpi	r22, 0x01	; 1
     d72:	09 f0       	breq	.+2      	; 0xd76 <TIMER_DELAY+0xe>
     d74:	08 95       	ret
		{
			case Timer0: 
			     OCR0 = Top_Value;
			break;
			case Timer2:
			     OCR2 = Top_Value;
     d76:	43 bd       	out	0x23, r20	; 35
     d78:	08 95       	ret

00000d7a <TIMER_WAVEGEN_NPWM>:
		}
	}
	
	
	void TIMER_WAVEGEN_NPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     d7a:	cf 93       	push	r28
     d7c:	c4 2f       	mov	r28, r20
		switch (t.timer_Number)
     d7e:	66 23       	and	r22, r22
     d80:	79 f4       	brne	.+30     	; 0xda0 <TIMER_WAVEGEN_NPWM+0x26>
		{
			case Timer0 :
				/* Set The Value Of OCR0 That will Wave Change after it */
				OCR0 = Top_Value;
     d82:	2c bf       	out	0x3c, r18	; 60
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     d84:	86 e3       	ldi	r24, 0x36	; 54
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	63 e0       	ldi	r22, 0x03	; 3
     d8a:	42 e0       	ldi	r20, 0x02	; 2
     d8c:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
				/* Switch on the form we want the signal get out after each compare match */
				switch(wave)
     d90:	c2 30       	cpi	r28, 0x02	; 2
     d92:	e1 f0       	breq	.+56     	; 0xdcc <TIMER_WAVEGEN_NPWM+0x52>
     d94:	c3 30       	cpi	r28, 0x03	; 3
     d96:	41 f1       	breq	.+80     	; 0xde8 <TIMER_WAVEGEN_NPWM+0x6e>
     d98:	c1 30       	cpi	r28, 0x01	; 1
     d9a:	69 f1       	breq	.+90     	; 0xdf6 <TIMER_WAVEGEN_NPWM+0x7c>
			break;
			default:
			break;
		}
	
	}	
     d9c:	cf 91       	pop	r28
     d9e:	08 95       	ret
	}
	
	
	void TIMER_WAVEGEN_NPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
		switch (t.timer_Number)
     da0:	61 30       	cpi	r22, 0x01	; 1
     da2:	e1 f7       	brne	.-8      	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
					break;
				}
			break;
			case Timer2: 
				    /* Set The Value Of OCR2 That will Wave Change after it */
					OCR2 = Top_Value;
     da4:	23 bd       	out	0x23, r18	; 35
					/* at the first we set up the pin of the wave output in the Mc as output state OC2 pin */
					DIO_pinConfiguration(GPIOD,PIN7, Output);
     da6:	80 e3       	ldi	r24, 0x30	; 48
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	67 e0       	ldi	r22, 0x07	; 7
     dac:	42 e0       	ldi	r20, 0x02	; 2
     dae:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
					/* Switch on the form we want the signal get out after each compare match */
					switch(wave)
     db2:	c2 30       	cpi	r28, 0x02	; 2
     db4:	39 f1       	breq	.+78     	; 0xe04 <TIMER_WAVEGEN_NPWM+0x8a>
     db6:	c3 30       	cpi	r28, 0x03	; 3
     db8:	81 f0       	breq	.+32     	; 0xdda <TIMER_WAVEGEN_NPWM+0x60>
     dba:	c1 30       	cpi	r28, 0x01	; 1
     dbc:	79 f7       	brne	.-34     	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
					{
						case NON:
						/* This is The Normal State when the COM00 and COM01 is cleared */
						break;
						case Toggle_PB_InCM:
							 RESET_Bit(TCCR2, COM21);
     dbe:	85 b5       	in	r24, 0x25	; 37
     dc0:	8f 7d       	andi	r24, 0xDF	; 223
     dc2:	85 bd       	out	0x25, r24	; 37
							 SET_Bit(TCCR2, COM20);
     dc4:	85 b5       	in	r24, 0x25	; 37
     dc6:	80 61       	ori	r24, 0x10	; 16
     dc8:	85 bd       	out	0x25, r24	; 37
						break;
     dca:	e8 cf       	rjmp	.-48     	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
					case Toggle_PB_InCM:
						 RESET_Bit(TCCR0, COM01);
						 SET_Bit(TCCR0, COM00);
					break;
					case Clear_PB_InCM:
						 SET_Bit(TCCR0, COM01);
     dcc:	83 b7       	in	r24, 0x33	; 51
     dce:	80 62       	ori	r24, 0x20	; 32
     dd0:	83 bf       	out	0x33, r24	; 51
						 RESET_Bit(TCCR0, COM00);
     dd2:	83 b7       	in	r24, 0x33	; 51
     dd4:	8f 7e       	andi	r24, 0xEF	; 239
     dd6:	83 bf       	out	0x33, r24	; 51
					break;
     dd8:	e1 cf       	rjmp	.-62     	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
						case Clear_PB_InCM:
							 SET_Bit(TCCR2, COM21);
							 RESET_Bit(TCCR2, COM20);
						break;
						case Set_PB_InCM:
							SET_Bit(TCCR2, COM21);
     dda:	85 b5       	in	r24, 0x25	; 37
     ddc:	80 62       	ori	r24, 0x20	; 32
     dde:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM20);
     de0:	85 b5       	in	r24, 0x25	; 37
     de2:	80 61       	ori	r24, 0x10	; 16
     de4:	85 bd       	out	0x25, r24	; 37
							break;
     de6:	da cf       	rjmp	.-76     	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
					case Clear_PB_InCM:
						 SET_Bit(TCCR0, COM01);
						 RESET_Bit(TCCR0, COM00);
					break;
					case Set_PB_InCM:
						SET_Bit(TCCR0, COM01);
     de8:	83 b7       	in	r24, 0x33	; 51
     dea:	80 62       	ori	r24, 0x20	; 32
     dec:	83 bf       	out	0x33, r24	; 51
						SET_Bit(TCCR0, COM00);
     dee:	83 b7       	in	r24, 0x33	; 51
     df0:	80 61       	ori	r24, 0x10	; 16
     df2:	83 bf       	out	0x33, r24	; 51
						break;
     df4:	d3 cf       	rjmp	.-90     	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
				{
					case NON:
					/* This is The Normal State when the COM00 and COM01 is cleared */
					break;
					case Toggle_PB_InCM:
						 RESET_Bit(TCCR0, COM01);
     df6:	83 b7       	in	r24, 0x33	; 51
     df8:	8f 7d       	andi	r24, 0xDF	; 223
     dfa:	83 bf       	out	0x33, r24	; 51
						 SET_Bit(TCCR0, COM00);
     dfc:	83 b7       	in	r24, 0x33	; 51
     dfe:	80 61       	ori	r24, 0x10	; 16
     e00:	83 bf       	out	0x33, r24	; 51
					break;
     e02:	cc cf       	rjmp	.-104    	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>
						case Toggle_PB_InCM:
							 RESET_Bit(TCCR2, COM21);
							 SET_Bit(TCCR2, COM20);
						break;
						case Clear_PB_InCM:
							 SET_Bit(TCCR2, COM21);
     e04:	85 b5       	in	r24, 0x25	; 37
     e06:	80 62       	ori	r24, 0x20	; 32
     e08:	85 bd       	out	0x25, r24	; 37
							 RESET_Bit(TCCR2, COM20);
     e0a:	85 b5       	in	r24, 0x25	; 37
     e0c:	8f 7e       	andi	r24, 0xEF	; 239
     e0e:	85 bd       	out	0x25, r24	; 37
						break;
     e10:	c5 cf       	rjmp	.-118    	; 0xd9c <TIMER_WAVEGEN_NPWM+0x22>

00000e12 <TIMER_WAVEGEN_FASTPWM>:
			break;
		}
	
	}	
	void TIMER_WAVEGEN_FASTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     e12:	cf 93       	push	r28
     e14:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     e16:	66 23       	and	r22, r22
     e18:	a9 f4       	brne	.+42     	; 0xe44 <TIMER_WAVEGEN_FASTPWM+0x32>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR0 = Top_Value;
     e1a:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     e1c:	86 e3       	ldi	r24, 0x36	; 54
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	63 e0       	ldi	r22, 0x03	; 3
     e22:	42 e0       	ldi	r20, 0x02	; 2
     e24:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     e28:	c4 30       	cpi	r28, 0x04	; 4
     e2a:	19 f1       	breq	.+70     	; 0xe72 <TIMER_WAVEGEN_FASTPWM+0x60>
     e2c:	c5 30       	cpi	r28, 0x05	; 5
     e2e:	11 f0       	breq	.+4      	; 0xe34 <TIMER_WAVEGEN_FASTPWM+0x22>
     e30:	cc 23       	and	r28, r28
     e32:	31 f4       	brne	.+12     	; 0xe40 <TIMER_WAVEGEN_FASTPWM+0x2e>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR0, COM00);
     e34:	83 b7       	in	r24, 0x33	; 51
     e36:	8f 7e       	andi	r24, 0xEF	; 239
     e38:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     e3a:	83 b7       	in	r24, 0x33	; 51
     e3c:	80 62       	ori	r24, 0x20	; 32
     e3e:	83 bf       	out	0x33, r24	; 51
			default :
			break;
		}
		
		
	}	
     e40:	cf 91       	pop	r28
     e42:	08 95       	ret
		}
	
	}	
	void TIMER_WAVEGEN_FASTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     e44:	61 30       	cpi	r22, 0x01	; 1
     e46:	e1 f7       	brne	.-8      	; 0xe40 <TIMER_WAVEGEN_FASTPWM+0x2e>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR2 = Top_Value;
     e48:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     e4a:	80 e3       	ldi	r24, 0x30	; 48
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	67 e0       	ldi	r22, 0x07	; 7
     e50:	42 e0       	ldi	r20, 0x02	; 2
     e52:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     e56:	c4 30       	cpi	r28, 0x04	; 4
     e58:	a1 f0       	breq	.+40     	; 0xe82 <TIMER_WAVEGEN_FASTPWM+0x70>
     e5a:	c5 30       	cpi	r28, 0x05	; 5
     e5c:	11 f0       	breq	.+4      	; 0xe62 <TIMER_WAVEGEN_FASTPWM+0x50>
     e5e:	cc 23       	and	r28, r28
     e60:	79 f7       	brne	.-34     	; 0xe40 <TIMER_WAVEGEN_FASTPWM+0x2e>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR2, COM20);
     e62:	85 b5       	in	r24, 0x25	; 37
     e64:	8f 7e       	andi	r24, 0xEF	; 239
     e66:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     e68:	85 b5       	in	r24, 0x25	; 37
     e6a:	80 62       	ori	r24, 0x20	; 32
     e6c:	85 bd       	out	0x25, r24	; 37
			default :
			break;
		}
		
		
	}	
     e6e:	cf 91       	pop	r28
     e70:	08 95       	ret
							RESET_Bit(TCCR0, COM00);
							SET_Bit(TCCR0, COM01);
					break;
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR0, COM00);
     e72:	83 b7       	in	r24, 0x33	; 51
     e74:	80 61       	ori	r24, 0x10	; 16
     e76:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     e78:	83 b7       	in	r24, 0x33	; 51
     e7a:	80 62       	ori	r24, 0x20	; 32
     e7c:	83 bf       	out	0x33, r24	; 51
			default :
			break;
		}
		
		
	}	
     e7e:	cf 91       	pop	r28
     e80:	08 95       	ret
							RESET_Bit(TCCR2, COM20);
							SET_Bit(TCCR2, COM21);
					break;
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR2, COM20);
     e82:	85 b5       	in	r24, 0x25	; 37
     e84:	80 61       	ori	r24, 0x10	; 16
     e86:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     e88:	85 b5       	in	r24, 0x25	; 37
     e8a:	80 62       	ori	r24, 0x20	; 32
     e8c:	85 bd       	out	0x25, r24	; 37
			default :
			break;
		}
		
		
	}	
     e8e:	cf 91       	pop	r28
     e90:	08 95       	ret

00000e92 <TIMER_WAVEGEN_PHACECORRECTPWM>:
	
	
	void TIMER_WAVEGEN_PHACECORRECTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     e92:	cf 93       	push	r28
     e94:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     e96:	66 23       	and	r22, r22
     e98:	a9 f4       	brne	.+42     	; 0xec4 <TIMER_WAVEGEN_PHACECORRECTPWM+0x32>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC0 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC0 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR0 = Top_Value;
     e9a:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     e9c:	86 e3       	ldi	r24, 0x36	; 54
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	63 e0       	ldi	r22, 0x03	; 3
     ea2:	42 e0       	ldi	r20, 0x02	; 2
     ea4:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     ea8:	c6 30       	cpi	r28, 0x06	; 6
     eaa:	21 f0       	breq	.+8      	; 0xeb4 <TIMER_WAVEGEN_PHACECORRECTPWM+0x22>
     eac:	c7 30       	cpi	r28, 0x07	; 7
     eae:	49 f1       	breq	.+82     	; 0xf02 <TIMER_WAVEGEN_PHACECORRECTPWM+0x70>
     eb0:	cc 23       	and	r28, r28
     eb2:	31 f4       	brne	.+12     	; 0xec0 <TIMER_WAVEGEN_PHACECORRECTPWM+0x2e>
					case NON:
					/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is clear when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR0, COM00);
     eb4:	83 b7       	in	r24, 0x33	; 51
     eb6:	8f 7e       	andi	r24, 0xEF	; 239
     eb8:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     eba:	83 b7       	in	r24, 0x33	; 51
     ebc:	80 62       	ori	r24, 0x20	; 32
     ebe:	83 bf       	out	0x33, r24	; 51
			break;
			default: 
			
			break;
		}		
	}	
     ec0:	cf 91       	pop	r28
     ec2:	08 95       	ret
	}	
	
	
	void TIMER_WAVEGEN_PHACECORRECTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     ec4:	61 30       	cpi	r22, 0x01	; 1
     ec6:	e1 f7       	brne	.-8      	; 0xec0 <TIMER_WAVEGEN_PHACECORRECTPWM+0x2e>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC2 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC2 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR2 = Top_Value;
     ec8:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     eca:	80 e3       	ldi	r24, 0x30	; 48
     ecc:	90 e0       	ldi	r25, 0x00	; 0
     ece:	67 e0       	ldi	r22, 0x07	; 7
     ed0:	42 e0       	ldi	r20, 0x02	; 2
     ed2:	0e 94 1f 05 	call	0xa3e	; 0xa3e <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     ed6:	c6 30       	cpi	r28, 0x06	; 6
     ed8:	21 f0       	breq	.+8      	; 0xee2 <TIMER_WAVEGEN_PHACECORRECTPWM+0x50>
     eda:	c7 30       	cpi	r28, 0x07	; 7
     edc:	51 f0       	breq	.+20     	; 0xef2 <TIMER_WAVEGEN_PHACECORRECTPWM+0x60>
     ede:	cc 23       	and	r28, r28
     ee0:	79 f7       	brne	.-34     	; 0xec0 <TIMER_WAVEGEN_PHACECORRECTPWM+0x2e>
					case NON:
					/* This IS the normal mode OC2 IS disconnected when the COM20 and COM21 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is clear when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR2, COM20);
     ee2:	85 b5       	in	r24, 0x25	; 37
     ee4:	8f 7e       	andi	r24, 0xEF	; 239
     ee6:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     ee8:	85 b5       	in	r24, 0x25	; 37
     eea:	80 62       	ori	r24, 0x20	; 32
     eec:	85 bd       	out	0x25, r24	; 37
			break;
			default: 
			
			break;
		}		
	}	
     eee:	cf 91       	pop	r28
     ef0:	08 95       	ret
					RESET_Bit(TCCR2, COM20);
					SET_Bit(TCCR2, COM21);
					break;
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is set when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR2, COM20);
     ef2:	85 b5       	in	r24, 0x25	; 37
     ef4:	80 61       	ori	r24, 0x10	; 16
     ef6:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     ef8:	85 b5       	in	r24, 0x25	; 37
     efa:	80 62       	ori	r24, 0x20	; 32
     efc:	85 bd       	out	0x25, r24	; 37
			break;
			default: 
			
			break;
		}		
	}	
     efe:	cf 91       	pop	r28
     f00:	08 95       	ret
					RESET_Bit(TCCR0, COM00);
					SET_Bit(TCCR0, COM01);
					break;
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is set when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR0, COM00);
     f02:	83 b7       	in	r24, 0x33	; 51
     f04:	80 61       	ori	r24, 0x10	; 16
     f06:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     f08:	83 b7       	in	r24, 0x33	; 51
     f0a:	80 62       	ori	r24, 0x20	; 32
     f0c:	83 bf       	out	0x33, r24	; 51
			break;
			default: 
			
			break;
		}		
	}	
     f0e:	cf 91       	pop	r28
     f10:	08 95       	ret

00000f12 <USART_RXC_vect>:
		 * so it should write as ISR(_vector(13)) but this is define in the AVR/Interrupt 
		*/ 					 
							 
	/* interrupt function by the RXC */						 
	 ISR (USART_RXC_vect)
	 {
     f12:	1f 92       	push	r1
     f14:	0f 92       	push	r0
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	0f 92       	push	r0
     f1a:	11 24       	eor	r1, r1
     f1c:	2f 93       	push	r18
     f1e:	3f 93       	push	r19
     f20:	4f 93       	push	r20
     f22:	5f 93       	push	r21
     f24:	6f 93       	push	r22
     f26:	7f 93       	push	r23
     f28:	8f 93       	push	r24
     f2a:	9f 93       	push	r25
     f2c:	af 93       	push	r26
     f2e:	bf 93       	push	r27
     f30:	ef 93       	push	r30
     f32:	ff 93       	push	r31
		 if (USART0.RXC_InterruptCall != NULL)
     f34:	e0 91 8e 00 	lds	r30, 0x008E
     f38:	f0 91 8f 00 	lds	r31, 0x008F
     f3c:	30 97       	sbiw	r30, 0x00	; 0
     f3e:	09 f0       	breq	.+2      	; 0xf42 <USART_RXC_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.RXC_InterruptCall();
     f40:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     f42:	ff 91       	pop	r31
     f44:	ef 91       	pop	r30
     f46:	bf 91       	pop	r27
     f48:	af 91       	pop	r26
     f4a:	9f 91       	pop	r25
     f4c:	8f 91       	pop	r24
     f4e:	7f 91       	pop	r23
     f50:	6f 91       	pop	r22
     f52:	5f 91       	pop	r21
     f54:	4f 91       	pop	r20
     f56:	3f 91       	pop	r19
     f58:	2f 91       	pop	r18
     f5a:	0f 90       	pop	r0
     f5c:	0f be       	out	0x3f, r0	; 63
     f5e:	0f 90       	pop	r0
     f60:	1f 90       	pop	r1
     f62:	18 95       	reti

00000f64 <USART_TXC_vect>:
	 
	 
	 /* interrupt function by the RXC */						 
	 ISR (USART_TXC_vect)
	 {
     f64:	1f 92       	push	r1
     f66:	0f 92       	push	r0
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	0f 92       	push	r0
     f6c:	11 24       	eor	r1, r1
     f6e:	2f 93       	push	r18
     f70:	3f 93       	push	r19
     f72:	4f 93       	push	r20
     f74:	5f 93       	push	r21
     f76:	6f 93       	push	r22
     f78:	7f 93       	push	r23
     f7a:	8f 93       	push	r24
     f7c:	9f 93       	push	r25
     f7e:	af 93       	push	r26
     f80:	bf 93       	push	r27
     f82:	ef 93       	push	r30
     f84:	ff 93       	push	r31
		 if (USART0.TXC_InterruptCall != NULL)
     f86:	e0 91 90 00 	lds	r30, 0x0090
     f8a:	f0 91 91 00 	lds	r31, 0x0091
     f8e:	30 97       	sbiw	r30, 0x00	; 0
     f90:	09 f0       	breq	.+2      	; 0xf94 <USART_TXC_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.TXC_InterruptCall();
     f92:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     f94:	ff 91       	pop	r31
     f96:	ef 91       	pop	r30
     f98:	bf 91       	pop	r27
     f9a:	af 91       	pop	r26
     f9c:	9f 91       	pop	r25
     f9e:	8f 91       	pop	r24
     fa0:	7f 91       	pop	r23
     fa2:	6f 91       	pop	r22
     fa4:	5f 91       	pop	r21
     fa6:	4f 91       	pop	r20
     fa8:	3f 91       	pop	r19
     faa:	2f 91       	pop	r18
     fac:	0f 90       	pop	r0
     fae:	0f be       	out	0x3f, r0	; 63
     fb0:	0f 90       	pop	r0
     fb2:	1f 90       	pop	r1
     fb4:	18 95       	reti

00000fb6 <USART_UDRE_vect>:
	 
	 
	 /* interrupt function by the UDRE */						 
	 ISR (USART_UDRE_vect)
	 {
     fb6:	1f 92       	push	r1
     fb8:	0f 92       	push	r0
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	0f 92       	push	r0
     fbe:	11 24       	eor	r1, r1
     fc0:	2f 93       	push	r18
     fc2:	3f 93       	push	r19
     fc4:	4f 93       	push	r20
     fc6:	5f 93       	push	r21
     fc8:	6f 93       	push	r22
     fca:	7f 93       	push	r23
     fcc:	8f 93       	push	r24
     fce:	9f 93       	push	r25
     fd0:	af 93       	push	r26
     fd2:	bf 93       	push	r27
     fd4:	ef 93       	push	r30
     fd6:	ff 93       	push	r31
		 if (USART0.UDRE_InterruptCall != NULL)
     fd8:	e0 91 92 00 	lds	r30, 0x0092
     fdc:	f0 91 93 00 	lds	r31, 0x0093
     fe0:	30 97       	sbiw	r30, 0x00	; 0
     fe2:	09 f0       	breq	.+2      	; 0xfe6 <USART_UDRE_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.UDRE_InterruptCall();
     fe4:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     fe6:	ff 91       	pop	r31
     fe8:	ef 91       	pop	r30
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	0f 90       	pop	r0
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	0f 90       	pop	r0
    1004:	1f 90       	pop	r1
    1006:	18 95       	reti

00001008 <USART_Intia>:
	
	  void USART_Intia(void)
	  {
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
		  switch(USART0.communicationTerminal)
		  {
			  case USART_SingleProcessor:
			  break;
			  case USART_MultiProcessor:
			       UCSRA_Temp |= (1<<MPCM);
    1014:	e0 91 82 00 	lds	r30, 0x0082
    1018:	e1 50       	subi	r30, 0x01	; 1
    101a:	e3 30       	cpi	r30, 0x03	; 3
    101c:	30 f5       	brcc	.+76     	; 0x106a <USART_Intia+0x62>
    101e:	f0 e0       	ldi	r31, 0x00	; 0
    1020:	e8 58       	subi	r30, 0x88	; 136
    1022:	ff 4f       	sbci	r31, 0xFF	; 255
    1024:	c0 81       	ld	r28, Z
			  break;
			  default:
			  break;
		  }	
		  
		  switch(USART0.communicationMode)
    1026:	80 91 83 00 	lds	r24, 0x0083
    102a:	81 30       	cpi	r24, 0x01	; 1
    102c:	19 f1       	breq	.+70     	; 0x1074 <USART_Intia+0x6c>
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	90 f1       	brcs	.+100    	; 0x1096 <USART_Intia+0x8e>
    1032:	82 30       	cpi	r24, 0x02	; 2
    1034:	09 f4       	brne	.+2      	; 0x1038 <USART_Intia+0x30>
    1036:	7e c0       	rjmp	.+252    	; 0x1134 <USART_Intia+0x12c>
    1038:	21 e0       	ldi	r18, 0x01	; 1
    103a:	60 e0       	ldi	r22, 0x00	; 0
    103c:	d0 e0       	ldi	r29, 0x00	; 0
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
    103e:	90 e0       	ldi	r25, 0x00	; 0
			 break;
			  default:
			  break;
		  }
		  
		  switch(USART0.communicationTerminal)
    1040:	80 91 84 00 	lds	r24, 0x0084
    1044:	81 30       	cpi	r24, 0x01	; 1
    1046:	09 f4       	brne	.+2      	; 0x104a <USART_Intia+0x42>
		  {
			  case USART_SingleProcessor:
			  break;
			  case USART_MultiProcessor:
			       UCSRA_Temp |= (1<<MPCM);
    1048:	92 2f       	mov	r25, r18
			  break;
			  default:
			  break;
		  }
		  
		  switch (USART0.interruptSource)
    104a:	80 91 85 00 	lds	r24, 0x0085
    104e:	84 30       	cpi	r24, 0x04	; 4
    1050:	09 f4       	brne	.+2      	; 0x1054 <USART_Intia+0x4c>
    1052:	ae c0       	rjmp	.+348    	; 0x11b0 <USART_Intia+0x1a8>
    1054:	85 30       	cpi	r24, 0x05	; 5
    1056:	08 f0       	brcs	.+2      	; 0x105a <USART_Intia+0x52>
    1058:	53 c0       	rjmp	.+166    	; 0x1100 <USART_Intia+0xf8>
    105a:	82 30       	cpi	r24, 0x02	; 2
    105c:	09 f4       	brne	.+2      	; 0x1060 <USART_Intia+0x58>
    105e:	a6 c0       	rjmp	.+332    	; 0x11ac <USART_Intia+0x1a4>
    1060:	83 30       	cpi	r24, 0x03	; 3
    1062:	08 f4       	brcc	.+2      	; 0x1066 <USART_Intia+0x5e>
    1064:	9a c0       	rjmp	.+308    	; 0x119a <USART_Intia+0x192>
			break;
			case USART_TxComInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE);
			break;
			case USART_UDRInt_Enable:
			     UCSRB_Temp |= (1<<UDRIE);
    1066:	c0 62       	ori	r28, 0x20	; 32
			break;
    1068:	54 c0       	rjmp	.+168    	; 0x1112 <USART_Intia+0x10a>
		  unsigned char UCSRA_Temp = 0;
		  unsigned char UCSRB_Temp = 0;
		  unsigned char UCSRC_Temp = 0;
		  float   UBRR_Temp = 0.0;
		  
		  switch (USART0.enableMode)
    106a:	c0 e0       	ldi	r28, 0x00	; 0
			  break;
			  default:
			  break;
		  }	
		  
		  switch(USART0.communicationMode)
    106c:	80 91 83 00 	lds	r24, 0x0083
    1070:	81 30       	cpi	r24, 0x01	; 1
    1072:	e9 f6       	brne	.-70     	; 0x102e <USART_Intia+0x26>
			       UCSRA_Temp |= (1<<U2X);
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
			  break;
			  
			  case USART_Asyn_SingleSpeed:
			       UBRR_Temp = (((float)F_CPU) / (16.0 * USART0.baudRate)) - 0.5;
    1074:	60 91 8a 00 	lds	r22, 0x008A
    1078:	70 91 8b 00 	lds	r23, 0x008B
    107c:	80 91 8c 00 	lds	r24, 0x008C
    1080:	90 91 8d 00 	lds	r25, 0x008D
    1084:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__floatunsisf>
    1088:	20 e0       	ldi	r18, 0x00	; 0
    108a:	30 e0       	ldi	r19, 0x00	; 0
    108c:	40 e8       	ldi	r20, 0x80	; 128
    108e:	51 e4       	ldi	r21, 0x41	; 65
    1090:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <__mulsf3>
    1094:	5d c0       	rjmp	.+186    	; 0x1150 <USART_Intia+0x148>
		  
		  switch(USART0.communicationMode)
		  {
			  case USART_Asyn_DoupleSpeed:
			       UCSRA_Temp |= (1<<U2X);
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
    1096:	60 91 8a 00 	lds	r22, 0x008A
    109a:	70 91 8b 00 	lds	r23, 0x008B
    109e:	80 91 8c 00 	lds	r24, 0x008C
    10a2:	90 91 8d 00 	lds	r25, 0x008D
    10a6:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__floatunsisf>
    10aa:	20 e0       	ldi	r18, 0x00	; 0
    10ac:	30 e0       	ldi	r19, 0x00	; 0
    10ae:	40 e0       	ldi	r20, 0x00	; 0
    10b0:	51 e4       	ldi	r21, 0x41	; 65
    10b2:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <__mulsf3>
    10b6:	9b 01       	movw	r18, r22
    10b8:	ac 01       	movw	r20, r24
    10ba:	60 e0       	ldi	r22, 0x00	; 0
    10bc:	74 e2       	ldi	r23, 0x24	; 36
    10be:	84 e7       	ldi	r24, 0x74	; 116
    10c0:	9b e4       	ldi	r25, 0x4B	; 75
    10c2:	0e 94 bf 09 	call	0x137e	; 0x137e <__divsf3>
    10c6:	20 e0       	ldi	r18, 0x00	; 0
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	40 e0       	ldi	r20, 0x00	; 0
    10cc:	5f e3       	ldi	r21, 0x3F	; 63
    10ce:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <__subsf3>
    10d2:	7b 01       	movw	r14, r22
    10d4:	8c 01       	movw	r16, r24
    10d6:	98 2f       	mov	r25, r24
    10d8:	4e 2d       	mov	r20, r14
    10da:	5f 2d       	mov	r21, r15
    10dc:	69 2f       	mov	r22, r25
    10de:	71 2f       	mov	r23, r17
    10e0:	cb 01       	movw	r24, r22
    10e2:	ba 01       	movw	r22, r20
    10e4:	0e 94 27 0a 	call	0x144e	; 0x144e <__fixunssfsi>
    10e8:	d7 2f       	mov	r29, r23
    10ea:	8e 2d       	mov	r24, r14
    10ec:	9f 2d       	mov	r25, r15
    10ee:	a0 2f       	mov	r26, r16
    10f0:	b1 2f       	mov	r27, r17
    10f2:	bc 01       	movw	r22, r24
    10f4:	cd 01       	movw	r24, r26
    10f6:	0e 94 27 0a 	call	0x144e	; 0x144e <__fixunssfsi>
			  break;
    10fa:	23 e0       	ldi	r18, 0x03	; 3
		  }	
		  
		  switch(USART0.communicationMode)
		  {
			  case USART_Asyn_DoupleSpeed:
			       UCSRA_Temp |= (1<<U2X);
    10fc:	92 e0       	ldi	r25, 0x02	; 2
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
			  break;
    10fe:	a0 cf       	rjmp	.-192    	; 0x1040 <USART_Intia+0x38>
			  break;
			  default:
			  break;
		  }
		  
		  switch (USART0.interruptSource)
    1100:	86 30       	cpi	r24, 0x06	; 6
    1102:	09 f4       	brne	.+2      	; 0x1106 <USART_Intia+0xfe>
    1104:	51 c0       	rjmp	.+162    	; 0x11a8 <USART_Intia+0x1a0>
    1106:	86 30       	cpi	r24, 0x06	; 6
    1108:	08 f4       	brcc	.+2      	; 0x110c <USART_Intia+0x104>
    110a:	4c c0       	rjmp	.+152    	; 0x11a4 <USART_Intia+0x19c>
    110c:	87 30       	cpi	r24, 0x07	; 7
    110e:	09 f4       	brne	.+2      	; 0x1112 <USART_Intia+0x10a>
			break;
			case USART_TxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE);
			break;
			case USART_InterruptsEnable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE) | (1<<RXCIE);
    1110:	c0 6e       	ori	r28, 0xE0	; 224
			default:
			break;
		  }
		  
		  
		  switch(USART0.dataFrame)
    1112:	80 91 86 00 	lds	r24, 0x0086
    1116:	84 30       	cpi	r24, 0x04	; 4
    1118:	09 f4       	brne	.+2      	; 0x111c <USART_Intia+0x114>
			  case USART_8bitData:
			       UCSRC_Temp |= (1<<UCSZ0) | (1<<UCSZ1);
			  break;
			  case USART_9bitData:
			       UCSRC_Temp |= (1<<UCSZ0) | (1<<UCSZ1);
				   UCSRB_Temp |= (1<<UCSZ2);
    111a:	c4 60       	ori	r28, 0x04	; 4
			  default:
			  break;
		  }
		  
		  
		  UCSRA = UCSRA_Temp;
    111c:	9b b9       	out	0x0b, r25	; 11
		  UCSRC = UCSRB_Temp;
    111e:	c0 bd       	out	0x20, r28	; 32
		  UBRRH = ((unsigned short)UBRR_Temp)>>8;
    1120:	d0 bd       	out	0x20, r29	; 32
		  UBRRL = ((unsigned char)UBRR_Temp);
    1122:	69 b9       	out	0x09, r22	; 9
		  UCSRB = UCSRB_Temp; //put in the last because on it the enable bit of the UART
    1124:	ca b9       	out	0x0a, r28	; 10
		  		  
	  }
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	1f 91       	pop	r17
    112c:	0f 91       	pop	r16
    112e:	ff 90       	pop	r15
    1130:	ef 90       	pop	r14
    1132:	08 95       	ret
			       UBRR_Temp = (((float)F_CPU) / (16.0 * USART0.baudRate)) - 0.5;
			  break;
			  
			  case USART_Sync:
			       UCSRC_Temp |= (1<<UMSEL);
				   UBRR_Temp = (((float)F_CPU) / (2.0 * USART0.baudRate)) - 0.5;
    1134:	60 91 8a 00 	lds	r22, 0x008A
    1138:	70 91 8b 00 	lds	r23, 0x008B
    113c:	80 91 8c 00 	lds	r24, 0x008C
    1140:	90 91 8d 00 	lds	r25, 0x008D
    1144:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__floatunsisf>
    1148:	9b 01       	movw	r18, r22
    114a:	ac 01       	movw	r20, r24
    114c:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <__addsf3>
    1150:	9b 01       	movw	r18, r22
    1152:	ac 01       	movw	r20, r24
    1154:	60 e0       	ldi	r22, 0x00	; 0
    1156:	74 e2       	ldi	r23, 0x24	; 36
    1158:	84 e7       	ldi	r24, 0x74	; 116
    115a:	9b e4       	ldi	r25, 0x4B	; 75
    115c:	0e 94 bf 09 	call	0x137e	; 0x137e <__divsf3>
    1160:	20 e0       	ldi	r18, 0x00	; 0
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	40 e0       	ldi	r20, 0x00	; 0
    1166:	5f e3       	ldi	r21, 0x3F	; 63
    1168:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <__subsf3>
    116c:	7b 01       	movw	r14, r22
    116e:	8c 01       	movw	r16, r24
    1170:	98 2f       	mov	r25, r24
    1172:	4e 2d       	mov	r20, r14
    1174:	5f 2d       	mov	r21, r15
    1176:	69 2f       	mov	r22, r25
    1178:	71 2f       	mov	r23, r17
    117a:	cb 01       	movw	r24, r22
    117c:	ba 01       	movw	r22, r20
    117e:	0e 94 27 0a 	call	0x144e	; 0x144e <__fixunssfsi>
    1182:	d7 2f       	mov	r29, r23
    1184:	8e 2d       	mov	r24, r14
    1186:	9f 2d       	mov	r25, r15
    1188:	a0 2f       	mov	r26, r16
    118a:	b1 2f       	mov	r27, r17
    118c:	bc 01       	movw	r22, r24
    118e:	cd 01       	movw	r24, r26
    1190:	0e 94 27 0a 	call	0x144e	; 0x144e <__fixunssfsi>
    1194:	21 e0       	ldi	r18, 0x01	; 1
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	53 cf       	rjmp	.-346    	; 0x1040 <USART_Intia+0x38>
			  break;
			  default:
			  break;
		  }
		  
		  switch (USART0.interruptSource)
    119a:	81 30       	cpi	r24, 0x01	; 1
    119c:	09 f0       	breq	.+2      	; 0x11a0 <USART_Intia+0x198>
    119e:	b9 cf       	rjmp	.-142    	; 0x1112 <USART_Intia+0x10a>
		  {
		    case USART_InterruptsDisable:
		  	break;
			case USART_RxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE);
    11a0:	c0 68       	ori	r28, 0x80	; 128
			break;
    11a2:	b7 cf       	rjmp	.-146    	; 0x1112 <USART_Intia+0x10a>
			break;
			case USART_RxTxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<TXCIE);
			break;
			case USART_RxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<UDRIE);
    11a4:	c0 6a       	ori	r28, 0xA0	; 160
			break;
    11a6:	b5 cf       	rjmp	.-150    	; 0x1112 <USART_Intia+0x10a>
			case USART_TxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE);
    11a8:	c0 66       	ori	r28, 0x60	; 96
			break;
    11aa:	b3 cf       	rjmp	.-154    	; 0x1112 <USART_Intia+0x10a>
		  	break;
			case USART_RxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE);
			break;
			case USART_TxComInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE);
    11ac:	c0 64       	ori	r28, 0x40	; 64
			break;
    11ae:	b1 cf       	rjmp	.-158    	; 0x1112 <USART_Intia+0x10a>
			case USART_UDRInt_Enable:
			     UCSRB_Temp |= (1<<UDRIE);
			break;
			case USART_RxTxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<TXCIE);
    11b0:	c0 6c       	ori	r28, 0xC0	; 192
			break;
    11b2:	af cf       	rjmp	.-162    	; 0x1112 <USART_Intia+0x10a>

000011b4 <USART_SendByte_Blocking>:
		  		  
	  }
	  
	  void USART_SendByte_Blocking(unsigned short Data)
	  {
		  while ((UCSRA & (1<<UDRE)) == 0)
    11b4:	5d 9b       	sbis	0x0b, 5	; 11
    11b6:	fe cf       	rjmp	.-4      	; 0x11b4 <USART_SendByte_Blocking>
		  {
			  /* this to blocking on the bit UDRE until it change to 1 to start transmit*/
		  }
		  if (USART0.dataFrame == USART_9bitData)
    11b8:	20 91 86 00 	lds	r18, 0x0086
    11bc:	24 30       	cpi	r18, 0x04	; 4
    11be:	39 f4       	brne	.+14     	; 0x11ce <USART_SendByte_Blocking+0x1a>
			  /*
			   * UCSRB & 1111 1110 to make sure the bit 0 is reset to hold the new value because it does not mention in data sheet
			   * we need to take the bit 9  in the data and hold it in the bit 0  in the UCSRB so we & the data with 8 to get 
			   *  and shift it again to put in the position of the bit 0
			   */ 
			  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
    11c0:	4a b1       	in	r20, 0x0a	; 10
    11c2:	9c 01       	movw	r18, r24
    11c4:	20 70       	andi	r18, 0x00	; 0
    11c6:	31 70       	andi	r19, 0x01	; 1
    11c8:	4e 7f       	andi	r20, 0xFE	; 254
    11ca:	43 2b       	or	r20, r19
    11cc:	4a b9       	out	0x0a, r20	; 10
		  }
		  /* casting the data to char to get only the 8 bit */
		  UDR = (unsigned char) Data;
    11ce:	8c b9       	out	0x0c, r24	; 12
	  }
    11d0:	08 95       	ret

000011d2 <USART_SendByte_NoneBlocking>:
	  
	  /* this function is use in case called by interrupt */
	  void USART_SendByte_NoneBlocking(unsigned short Data)
	  {
		  if ((UCSRA & (1<<UDRE)) != 0)
    11d2:	5d 9b       	sbis	0x0b, 5	; 11
    11d4:	05 c0       	rjmp	.+10     	; 0x11e0 <USART_SendByte_NoneBlocking+0xe>
		  {
			
			  if (USART0.dataFrame == USART_9bitData)
    11d6:	20 91 86 00 	lds	r18, 0x0086
    11da:	24 30       	cpi	r18, 0x04	; 4
    11dc:	11 f0       	breq	.+4      	; 0x11e2 <USART_SendByte_NoneBlocking+0x10>
					   and shift it again to put in the position of the bit 0
				  */ 
				  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
			  }
			  /* casting the data to char to get only the 8 bit */
			  UDR = (unsigned char) Data;
    11de:	8c b9       	out	0x0c, r24	; 12
    11e0:	08 95       	ret
				  /*
				   * UCSRB & 1111 1110 to make sure the bit 0 is reset to hold the new value because it does not mention in data sheet
				   * we need to take the bit 9  in the data and hold it in the bit 0  in the UCSRB so we & the data with 8 to get 
					   and shift it again to put in the position of the bit 0
				  */ 
				  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
    11e2:	4a b1       	in	r20, 0x0a	; 10
    11e4:	9c 01       	movw	r18, r24
    11e6:	20 70       	andi	r18, 0x00	; 0
    11e8:	31 70       	andi	r19, 0x01	; 1
    11ea:	4e 7f       	andi	r20, 0xFE	; 254
    11ec:	43 2b       	or	r20, r19
    11ee:	4a b9       	out	0x0a, r20	; 10
			  }
			  /* casting the data to char to get only the 8 bit */
			  UDR = (unsigned char) Data;
    11f0:	8c b9       	out	0x0c, r24	; 12
    11f2:	f6 cf       	rjmp	.-20     	; 0x11e0 <USART_SendByte_NoneBlocking+0xe>

000011f4 <USART_ReadByte_Blocking>:
	  unsigned short USART_ReadByte_Blocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
		  
		  while ((UCSRA & (1<<RXC)) == 0)
    11f4:	5f 9b       	sbis	0x0b, 7	; 11
    11f6:	fe cf       	rjmp	.-4      	; 0x11f4 <USART_ReadByte_Blocking>
		  {
			  /* this flag set when there was unread data in the receive buffer so we blocking until it set */ 
		  }
		  
		  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
    11f8:	8b b1       	in	r24, 0x0b	; 11
    11fa:	8c 71       	andi	r24, 0x1C	; 28
    11fc:	59 f4       	brne	.+22     	; 0x1214 <USART_ReadByte_Blocking+0x20>
				  USART0.errorType = USART_ParityError;
			  }
			  			  
		  }
		  
		  if(USART0.dataFrame == USART_9bitData)
    11fe:	80 91 86 00 	lds	r24, 0x0086
    1202:	84 30       	cpi	r24, 0x04	; 4
    1204:	69 f0       	breq	.+26     	; 0x1220 <USART_ReadByte_Blocking+0x2c>
	  }
	  
	  unsigned short USART_ReadByte_Blocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
    1206:	20 e0       	ldi	r18, 0x00	; 0
    1208:	30 e0       	ldi	r19, 0x00	; 0
		  {
			  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
			  RxData = ((UCSRB & (1<<RXB8)) << 7);
		  }
		  
		  RxData |= UDR;
    120a:	8c b1       	in	r24, 0x0c	; 12
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	82 2b       	or	r24, r18
    1210:	93 2b       	or	r25, r19
		  return RxData;
		  
	  }
    1212:	08 95       	ret
		  }
		  
		  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
		  {
			  /* error handle as you wish */
			  if(UCSRA & (1<<FE))
    1214:	5c 9b       	sbis	0x0b, 4	; 11
    1216:	0e c0       	rjmp	.+28     	; 0x1234 <USART_ReadByte_Blocking+0x40>
			  {
				  USART0.errorType = USART_FrameError;
    1218:	83 e0       	ldi	r24, 0x03	; 3
    121a:	80 93 89 00 	sts	0x0089, r24
    121e:	ef cf       	rjmp	.-34     	; 0x11fe <USART_ReadByte_Blocking+0xa>
		  }
		  
		  if(USART0.dataFrame == USART_9bitData)
		  {
			  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
			  RxData = ((UCSRB & (1<<RXB8)) << 7);
    1220:	2a b1       	in	r18, 0x0a	; 10
    1222:	30 e0       	ldi	r19, 0x00	; 0
    1224:	22 70       	andi	r18, 0x02	; 2
    1226:	30 70       	andi	r19, 0x00	; 0
    1228:	36 95       	lsr	r19
    122a:	32 2f       	mov	r19, r18
    122c:	22 27       	eor	r18, r18
    122e:	37 95       	ror	r19
    1230:	27 95       	ror	r18
    1232:	eb cf       	rjmp	.-42     	; 0x120a <USART_ReadByte_Blocking+0x16>
			  /* error handle as you wish */
			  if(UCSRA & (1<<FE))
			  {
				  USART0.errorType = USART_FrameError;
			  }	
			  else if(UCSRA & (1<<DOR))
    1234:	5b 9b       	sbis	0x0b, 3	; 11
    1236:	04 c0       	rjmp	.+8      	; 0x1240 <USART_ReadByte_Blocking+0x4c>
			  {
				  USART0.errorType = USART_OverRunError;
    1238:	82 e0       	ldi	r24, 0x02	; 2
    123a:	80 93 89 00 	sts	0x0089, r24
    123e:	df cf       	rjmp	.-66     	; 0x11fe <USART_ReadByte_Blocking+0xa>
			  }
			  else if(UCSRA & (1<<PE))
    1240:	5a 9b       	sbis	0x0b, 2	; 11
    1242:	dd cf       	rjmp	.-70     	; 0x11fe <USART_ReadByte_Blocking+0xa>
			  {
				  USART0.errorType = USART_ParityError;
    1244:	81 e0       	ldi	r24, 0x01	; 1
    1246:	80 93 89 00 	sts	0x0089, r24
    124a:	d9 cf       	rjmp	.-78     	; 0x11fe <USART_ReadByte_Blocking+0xa>

0000124c <USART_ReadByte_NoneBlocking>:
	  unsigned short USART_ReadByte_NoneBlocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
		  
		  if ((UCSRA & (1<<RXC)) != 0)
    124c:	5f 99       	sbic	0x0b, 7	; 11
    124e:	07 c0       	rjmp	.+14     	; 0x125e <USART_ReadByte_NoneBlocking+0x12>
	  
	  
	  unsigned short USART_ReadByte_NoneBlocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
    1250:	20 e0       	ldi	r18, 0x00	; 0
    1252:	30 e0       	ldi	r19, 0x00	; 0
				  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
				  RxData = ((UCSRB & (1<<RXB8)) << 7);
			  }
		  }			
		  
			RxData |= UDR;
    1254:	8c b1       	in	r24, 0x0c	; 12
    1256:	90 e0       	ldi	r25, 0x00	; 0
    1258:	82 2b       	or	r24, r18
    125a:	93 2b       	or	r25, r19
			return RxData;
		 	  
		  
    125c:	08 95       	ret
		  unsigned short RxData = 0x00;
		  
		  if ((UCSRA & (1<<RXC)) != 0)
		  {
		  
			  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
    125e:	8b b1       	in	r24, 0x0b	; 11
    1260:	8c 71       	andi	r24, 0x1C	; 28
    1262:	29 f0       	breq	.+10     	; 0x126e <USART_ReadByte_NoneBlocking+0x22>
			  {
				  /* error handle as you wish */
				  if(UCSRA & (1<<FE))
    1264:	5c 9b       	sbis	0x0b, 4	; 11
    1266:	15 c0       	rjmp	.+42     	; 0x1292 <USART_ReadByte_NoneBlocking+0x46>
				  {
					  USART0.errorType = USART_FrameError;
    1268:	83 e0       	ldi	r24, 0x03	; 3
    126a:	80 93 89 00 	sts	0x0089, r24
					  USART0.errorType = USART_ParityError;
				  }
			  
			  }
		  
			  if(USART0.dataFrame == USART_9bitData)
    126e:	80 91 86 00 	lds	r24, 0x0086
    1272:	84 30       	cpi	r24, 0x04	; 4
    1274:	69 f7       	brne	.-38     	; 0x1250 <USART_ReadByte_NoneBlocking+0x4>
			  {
				  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
				  RxData = ((UCSRB & (1<<RXB8)) << 7);
    1276:	2a b1       	in	r18, 0x0a	; 10
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	22 70       	andi	r18, 0x02	; 2
    127c:	30 70       	andi	r19, 0x00	; 0
    127e:	36 95       	lsr	r19
    1280:	32 2f       	mov	r19, r18
    1282:	22 27       	eor	r18, r18
    1284:	37 95       	ror	r19
    1286:	27 95       	ror	r18
			  }
		  }			
		  
			RxData |= UDR;
    1288:	8c b1       	in	r24, 0x0c	; 12
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	82 2b       	or	r24, r18
    128e:	93 2b       	or	r25, r19
			return RxData;
		 	  
		  
    1290:	08 95       	ret
				  /* error handle as you wish */
				  if(UCSRA & (1<<FE))
				  {
					  USART0.errorType = USART_FrameError;
				  }
				  else if(UCSRA & (1<<DOR))
    1292:	5b 99       	sbic	0x0b, 3	; 11
    1294:	06 c0       	rjmp	.+12     	; 0x12a2 <USART_ReadByte_NoneBlocking+0x56>
				  {
					  USART0.errorType = USART_OverRunError;
				  }
				  else if(UCSRA & (1<<PE))
    1296:	5a 9b       	sbis	0x0b, 2	; 11
    1298:	ea cf       	rjmp	.-44     	; 0x126e <USART_ReadByte_NoneBlocking+0x22>
				  {
					  USART0.errorType = USART_ParityError;
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	80 93 89 00 	sts	0x0089, r24
    12a0:	e6 cf       	rjmp	.-52     	; 0x126e <USART_ReadByte_NoneBlocking+0x22>
				  {
					  USART0.errorType = USART_FrameError;
				  }
				  else if(UCSRA & (1<<DOR))
				  {
					  USART0.errorType = USART_OverRunError;
    12a2:	82 e0       	ldi	r24, 0x02	; 2
    12a4:	80 93 89 00 	sts	0x0089, r24
    12a8:	e2 cf       	rjmp	.-60     	; 0x126e <USART_ReadByte_NoneBlocking+0x22>

000012aa <main>:
#include "SectionA.h"


int main(void)
{
	SectionA_Intit();
    12aa:	0e 94 77 02 	call	0x4ee	; 0x4ee <SectionA_Intit>
    while(1)
    {
		
		SectionA_Operate();
    12ae:	0e 94 c2 02 	call	0x584	; 0x584 <SectionA_Operate>
    12b2:	fd cf       	rjmp	.-6      	; 0x12ae <main+0x4>

000012b4 <__subsf3>:
    12b4:	50 58       	subi	r21, 0x80	; 128

000012b6 <__addsf3>:
    12b6:	bb 27       	eor	r27, r27
    12b8:	aa 27       	eor	r26, r26
    12ba:	0e d0       	rcall	.+28     	; 0x12d8 <__addsf3x>
    12bc:	48 c1       	rjmp	.+656    	; 0x154e <__fp_round>
    12be:	39 d1       	rcall	.+626    	; 0x1532 <__fp_pscA>
    12c0:	30 f0       	brcs	.+12     	; 0x12ce <__addsf3+0x18>
    12c2:	3e d1       	rcall	.+636    	; 0x1540 <__fp_pscB>
    12c4:	20 f0       	brcs	.+8      	; 0x12ce <__addsf3+0x18>
    12c6:	31 f4       	brne	.+12     	; 0x12d4 <__addsf3+0x1e>
    12c8:	9f 3f       	cpi	r25, 0xFF	; 255
    12ca:	11 f4       	brne	.+4      	; 0x12d0 <__addsf3+0x1a>
    12cc:	1e f4       	brtc	.+6      	; 0x12d4 <__addsf3+0x1e>
    12ce:	2e c1       	rjmp	.+604    	; 0x152c <__fp_nan>
    12d0:	0e f4       	brtc	.+2      	; 0x12d4 <__addsf3+0x1e>
    12d2:	e0 95       	com	r30
    12d4:	e7 fb       	bst	r30, 7
    12d6:	24 c1       	rjmp	.+584    	; 0x1520 <__fp_inf>

000012d8 <__addsf3x>:
    12d8:	e9 2f       	mov	r30, r25
    12da:	4a d1       	rcall	.+660    	; 0x1570 <__fp_split3>
    12dc:	80 f3       	brcs	.-32     	; 0x12be <__addsf3+0x8>
    12de:	ba 17       	cp	r27, r26
    12e0:	62 07       	cpc	r22, r18
    12e2:	73 07       	cpc	r23, r19
    12e4:	84 07       	cpc	r24, r20
    12e6:	95 07       	cpc	r25, r21
    12e8:	18 f0       	brcs	.+6      	; 0x12f0 <__addsf3x+0x18>
    12ea:	71 f4       	brne	.+28     	; 0x1308 <__addsf3x+0x30>
    12ec:	9e f5       	brtc	.+102    	; 0x1354 <__addsf3x+0x7c>
    12ee:	62 c1       	rjmp	.+708    	; 0x15b4 <__fp_zero>
    12f0:	0e f4       	brtc	.+2      	; 0x12f4 <__addsf3x+0x1c>
    12f2:	e0 95       	com	r30
    12f4:	0b 2e       	mov	r0, r27
    12f6:	ba 2f       	mov	r27, r26
    12f8:	a0 2d       	mov	r26, r0
    12fa:	0b 01       	movw	r0, r22
    12fc:	b9 01       	movw	r22, r18
    12fe:	90 01       	movw	r18, r0
    1300:	0c 01       	movw	r0, r24
    1302:	ca 01       	movw	r24, r20
    1304:	a0 01       	movw	r20, r0
    1306:	11 24       	eor	r1, r1
    1308:	ff 27       	eor	r31, r31
    130a:	59 1b       	sub	r21, r25
    130c:	99 f0       	breq	.+38     	; 0x1334 <__addsf3x+0x5c>
    130e:	59 3f       	cpi	r21, 0xF9	; 249
    1310:	50 f4       	brcc	.+20     	; 0x1326 <__addsf3x+0x4e>
    1312:	50 3e       	cpi	r21, 0xE0	; 224
    1314:	68 f1       	brcs	.+90     	; 0x1370 <__addsf3x+0x98>
    1316:	1a 16       	cp	r1, r26
    1318:	f0 40       	sbci	r31, 0x00	; 0
    131a:	a2 2f       	mov	r26, r18
    131c:	23 2f       	mov	r18, r19
    131e:	34 2f       	mov	r19, r20
    1320:	44 27       	eor	r20, r20
    1322:	58 5f       	subi	r21, 0xF8	; 248
    1324:	f3 cf       	rjmp	.-26     	; 0x130c <__addsf3x+0x34>
    1326:	46 95       	lsr	r20
    1328:	37 95       	ror	r19
    132a:	27 95       	ror	r18
    132c:	a7 95       	ror	r26
    132e:	f0 40       	sbci	r31, 0x00	; 0
    1330:	53 95       	inc	r21
    1332:	c9 f7       	brne	.-14     	; 0x1326 <__addsf3x+0x4e>
    1334:	7e f4       	brtc	.+30     	; 0x1354 <__addsf3x+0x7c>
    1336:	1f 16       	cp	r1, r31
    1338:	ba 0b       	sbc	r27, r26
    133a:	62 0b       	sbc	r22, r18
    133c:	73 0b       	sbc	r23, r19
    133e:	84 0b       	sbc	r24, r20
    1340:	ba f0       	brmi	.+46     	; 0x1370 <__addsf3x+0x98>
    1342:	91 50       	subi	r25, 0x01	; 1
    1344:	a1 f0       	breq	.+40     	; 0x136e <__addsf3x+0x96>
    1346:	ff 0f       	add	r31, r31
    1348:	bb 1f       	adc	r27, r27
    134a:	66 1f       	adc	r22, r22
    134c:	77 1f       	adc	r23, r23
    134e:	88 1f       	adc	r24, r24
    1350:	c2 f7       	brpl	.-16     	; 0x1342 <__addsf3x+0x6a>
    1352:	0e c0       	rjmp	.+28     	; 0x1370 <__addsf3x+0x98>
    1354:	ba 0f       	add	r27, r26
    1356:	62 1f       	adc	r22, r18
    1358:	73 1f       	adc	r23, r19
    135a:	84 1f       	adc	r24, r20
    135c:	48 f4       	brcc	.+18     	; 0x1370 <__addsf3x+0x98>
    135e:	87 95       	ror	r24
    1360:	77 95       	ror	r23
    1362:	67 95       	ror	r22
    1364:	b7 95       	ror	r27
    1366:	f7 95       	ror	r31
    1368:	9e 3f       	cpi	r25, 0xFE	; 254
    136a:	08 f0       	brcs	.+2      	; 0x136e <__addsf3x+0x96>
    136c:	b3 cf       	rjmp	.-154    	; 0x12d4 <__addsf3+0x1e>
    136e:	93 95       	inc	r25
    1370:	88 0f       	add	r24, r24
    1372:	08 f0       	brcs	.+2      	; 0x1376 <__addsf3x+0x9e>
    1374:	99 27       	eor	r25, r25
    1376:	ee 0f       	add	r30, r30
    1378:	97 95       	ror	r25
    137a:	87 95       	ror	r24
    137c:	08 95       	ret

0000137e <__divsf3>:
    137e:	0c d0       	rcall	.+24     	; 0x1398 <__divsf3x>
    1380:	e6 c0       	rjmp	.+460    	; 0x154e <__fp_round>
    1382:	de d0       	rcall	.+444    	; 0x1540 <__fp_pscB>
    1384:	40 f0       	brcs	.+16     	; 0x1396 <__divsf3+0x18>
    1386:	d5 d0       	rcall	.+426    	; 0x1532 <__fp_pscA>
    1388:	30 f0       	brcs	.+12     	; 0x1396 <__divsf3+0x18>
    138a:	21 f4       	brne	.+8      	; 0x1394 <__divsf3+0x16>
    138c:	5f 3f       	cpi	r21, 0xFF	; 255
    138e:	19 f0       	breq	.+6      	; 0x1396 <__divsf3+0x18>
    1390:	c7 c0       	rjmp	.+398    	; 0x1520 <__fp_inf>
    1392:	51 11       	cpse	r21, r1
    1394:	10 c1       	rjmp	.+544    	; 0x15b6 <__fp_szero>
    1396:	ca c0       	rjmp	.+404    	; 0x152c <__fp_nan>

00001398 <__divsf3x>:
    1398:	eb d0       	rcall	.+470    	; 0x1570 <__fp_split3>
    139a:	98 f3       	brcs	.-26     	; 0x1382 <__divsf3+0x4>

0000139c <__divsf3_pse>:
    139c:	99 23       	and	r25, r25
    139e:	c9 f3       	breq	.-14     	; 0x1392 <__divsf3+0x14>
    13a0:	55 23       	and	r21, r21
    13a2:	b1 f3       	breq	.-20     	; 0x1390 <__divsf3+0x12>
    13a4:	95 1b       	sub	r25, r21
    13a6:	55 0b       	sbc	r21, r21
    13a8:	bb 27       	eor	r27, r27
    13aa:	aa 27       	eor	r26, r26
    13ac:	62 17       	cp	r22, r18
    13ae:	73 07       	cpc	r23, r19
    13b0:	84 07       	cpc	r24, r20
    13b2:	38 f0       	brcs	.+14     	; 0x13c2 <__divsf3_pse+0x26>
    13b4:	9f 5f       	subi	r25, 0xFF	; 255
    13b6:	5f 4f       	sbci	r21, 0xFF	; 255
    13b8:	22 0f       	add	r18, r18
    13ba:	33 1f       	adc	r19, r19
    13bc:	44 1f       	adc	r20, r20
    13be:	aa 1f       	adc	r26, r26
    13c0:	a9 f3       	breq	.-22     	; 0x13ac <__divsf3_pse+0x10>
    13c2:	33 d0       	rcall	.+102    	; 0x142a <__divsf3_pse+0x8e>
    13c4:	0e 2e       	mov	r0, r30
    13c6:	3a f0       	brmi	.+14     	; 0x13d6 <__divsf3_pse+0x3a>
    13c8:	e0 e8       	ldi	r30, 0x80	; 128
    13ca:	30 d0       	rcall	.+96     	; 0x142c <__divsf3_pse+0x90>
    13cc:	91 50       	subi	r25, 0x01	; 1
    13ce:	50 40       	sbci	r21, 0x00	; 0
    13d0:	e6 95       	lsr	r30
    13d2:	00 1c       	adc	r0, r0
    13d4:	ca f7       	brpl	.-14     	; 0x13c8 <__divsf3_pse+0x2c>
    13d6:	29 d0       	rcall	.+82     	; 0x142a <__divsf3_pse+0x8e>
    13d8:	fe 2f       	mov	r31, r30
    13da:	27 d0       	rcall	.+78     	; 0x142a <__divsf3_pse+0x8e>
    13dc:	66 0f       	add	r22, r22
    13de:	77 1f       	adc	r23, r23
    13e0:	88 1f       	adc	r24, r24
    13e2:	bb 1f       	adc	r27, r27
    13e4:	26 17       	cp	r18, r22
    13e6:	37 07       	cpc	r19, r23
    13e8:	48 07       	cpc	r20, r24
    13ea:	ab 07       	cpc	r26, r27
    13ec:	b0 e8       	ldi	r27, 0x80	; 128
    13ee:	09 f0       	breq	.+2      	; 0x13f2 <__divsf3_pse+0x56>
    13f0:	bb 0b       	sbc	r27, r27
    13f2:	80 2d       	mov	r24, r0
    13f4:	bf 01       	movw	r22, r30
    13f6:	ff 27       	eor	r31, r31
    13f8:	93 58       	subi	r25, 0x83	; 131
    13fa:	5f 4f       	sbci	r21, 0xFF	; 255
    13fc:	2a f0       	brmi	.+10     	; 0x1408 <__divsf3_pse+0x6c>
    13fe:	9e 3f       	cpi	r25, 0xFE	; 254
    1400:	51 05       	cpc	r21, r1
    1402:	68 f0       	brcs	.+26     	; 0x141e <__divsf3_pse+0x82>
    1404:	8d c0       	rjmp	.+282    	; 0x1520 <__fp_inf>
    1406:	d7 c0       	rjmp	.+430    	; 0x15b6 <__fp_szero>
    1408:	5f 3f       	cpi	r21, 0xFF	; 255
    140a:	ec f3       	brlt	.-6      	; 0x1406 <__divsf3_pse+0x6a>
    140c:	98 3e       	cpi	r25, 0xE8	; 232
    140e:	dc f3       	brlt	.-10     	; 0x1406 <__divsf3_pse+0x6a>
    1410:	86 95       	lsr	r24
    1412:	77 95       	ror	r23
    1414:	67 95       	ror	r22
    1416:	b7 95       	ror	r27
    1418:	f7 95       	ror	r31
    141a:	9f 5f       	subi	r25, 0xFF	; 255
    141c:	c9 f7       	brne	.-14     	; 0x1410 <__divsf3_pse+0x74>
    141e:	88 0f       	add	r24, r24
    1420:	91 1d       	adc	r25, r1
    1422:	96 95       	lsr	r25
    1424:	87 95       	ror	r24
    1426:	97 f9       	bld	r25, 7
    1428:	08 95       	ret
    142a:	e1 e0       	ldi	r30, 0x01	; 1
    142c:	66 0f       	add	r22, r22
    142e:	77 1f       	adc	r23, r23
    1430:	88 1f       	adc	r24, r24
    1432:	bb 1f       	adc	r27, r27
    1434:	62 17       	cp	r22, r18
    1436:	73 07       	cpc	r23, r19
    1438:	84 07       	cpc	r24, r20
    143a:	ba 07       	cpc	r27, r26
    143c:	20 f0       	brcs	.+8      	; 0x1446 <__divsf3_pse+0xaa>
    143e:	62 1b       	sub	r22, r18
    1440:	73 0b       	sbc	r23, r19
    1442:	84 0b       	sbc	r24, r20
    1444:	ba 0b       	sbc	r27, r26
    1446:	ee 1f       	adc	r30, r30
    1448:	88 f7       	brcc	.-30     	; 0x142c <__divsf3_pse+0x90>
    144a:	e0 95       	com	r30
    144c:	08 95       	ret

0000144e <__fixunssfsi>:
    144e:	98 d0       	rcall	.+304    	; 0x1580 <__fp_splitA>
    1450:	88 f0       	brcs	.+34     	; 0x1474 <__fixunssfsi+0x26>
    1452:	9f 57       	subi	r25, 0x7F	; 127
    1454:	90 f0       	brcs	.+36     	; 0x147a <__fixunssfsi+0x2c>
    1456:	b9 2f       	mov	r27, r25
    1458:	99 27       	eor	r25, r25
    145a:	b7 51       	subi	r27, 0x17	; 23
    145c:	a0 f0       	brcs	.+40     	; 0x1486 <__fixunssfsi+0x38>
    145e:	d1 f0       	breq	.+52     	; 0x1494 <__fixunssfsi+0x46>
    1460:	66 0f       	add	r22, r22
    1462:	77 1f       	adc	r23, r23
    1464:	88 1f       	adc	r24, r24
    1466:	99 1f       	adc	r25, r25
    1468:	1a f0       	brmi	.+6      	; 0x1470 <__fixunssfsi+0x22>
    146a:	ba 95       	dec	r27
    146c:	c9 f7       	brne	.-14     	; 0x1460 <__fixunssfsi+0x12>
    146e:	12 c0       	rjmp	.+36     	; 0x1494 <__fixunssfsi+0x46>
    1470:	b1 30       	cpi	r27, 0x01	; 1
    1472:	81 f0       	breq	.+32     	; 0x1494 <__fixunssfsi+0x46>
    1474:	9f d0       	rcall	.+318    	; 0x15b4 <__fp_zero>
    1476:	b1 e0       	ldi	r27, 0x01	; 1
    1478:	08 95       	ret
    147a:	9c c0       	rjmp	.+312    	; 0x15b4 <__fp_zero>
    147c:	67 2f       	mov	r22, r23
    147e:	78 2f       	mov	r23, r24
    1480:	88 27       	eor	r24, r24
    1482:	b8 5f       	subi	r27, 0xF8	; 248
    1484:	39 f0       	breq	.+14     	; 0x1494 <__fixunssfsi+0x46>
    1486:	b9 3f       	cpi	r27, 0xF9	; 249
    1488:	cc f3       	brlt	.-14     	; 0x147c <__fixunssfsi+0x2e>
    148a:	86 95       	lsr	r24
    148c:	77 95       	ror	r23
    148e:	67 95       	ror	r22
    1490:	b3 95       	inc	r27
    1492:	d9 f7       	brne	.-10     	; 0x148a <__fixunssfsi+0x3c>
    1494:	3e f4       	brtc	.+14     	; 0x14a4 <__fixunssfsi+0x56>
    1496:	90 95       	com	r25
    1498:	80 95       	com	r24
    149a:	70 95       	com	r23
    149c:	61 95       	neg	r22
    149e:	7f 4f       	sbci	r23, 0xFF	; 255
    14a0:	8f 4f       	sbci	r24, 0xFF	; 255
    14a2:	9f 4f       	sbci	r25, 0xFF	; 255
    14a4:	08 95       	ret

000014a6 <__floatunsisf>:
    14a6:	e8 94       	clt
    14a8:	09 c0       	rjmp	.+18     	; 0x14bc <__floatsisf+0x12>

000014aa <__floatsisf>:
    14aa:	97 fb       	bst	r25, 7
    14ac:	3e f4       	brtc	.+14     	; 0x14bc <__floatsisf+0x12>
    14ae:	90 95       	com	r25
    14b0:	80 95       	com	r24
    14b2:	70 95       	com	r23
    14b4:	61 95       	neg	r22
    14b6:	7f 4f       	sbci	r23, 0xFF	; 255
    14b8:	8f 4f       	sbci	r24, 0xFF	; 255
    14ba:	9f 4f       	sbci	r25, 0xFF	; 255
    14bc:	99 23       	and	r25, r25
    14be:	a9 f0       	breq	.+42     	; 0x14ea <__floatsisf+0x40>
    14c0:	f9 2f       	mov	r31, r25
    14c2:	96 e9       	ldi	r25, 0x96	; 150
    14c4:	bb 27       	eor	r27, r27
    14c6:	93 95       	inc	r25
    14c8:	f6 95       	lsr	r31
    14ca:	87 95       	ror	r24
    14cc:	77 95       	ror	r23
    14ce:	67 95       	ror	r22
    14d0:	b7 95       	ror	r27
    14d2:	f1 11       	cpse	r31, r1
    14d4:	f8 cf       	rjmp	.-16     	; 0x14c6 <__floatsisf+0x1c>
    14d6:	fa f4       	brpl	.+62     	; 0x1516 <__floatsisf+0x6c>
    14d8:	bb 0f       	add	r27, r27
    14da:	11 f4       	brne	.+4      	; 0x14e0 <__floatsisf+0x36>
    14dc:	60 ff       	sbrs	r22, 0
    14de:	1b c0       	rjmp	.+54     	; 0x1516 <__floatsisf+0x6c>
    14e0:	6f 5f       	subi	r22, 0xFF	; 255
    14e2:	7f 4f       	sbci	r23, 0xFF	; 255
    14e4:	8f 4f       	sbci	r24, 0xFF	; 255
    14e6:	9f 4f       	sbci	r25, 0xFF	; 255
    14e8:	16 c0       	rjmp	.+44     	; 0x1516 <__floatsisf+0x6c>
    14ea:	88 23       	and	r24, r24
    14ec:	11 f0       	breq	.+4      	; 0x14f2 <__floatsisf+0x48>
    14ee:	96 e9       	ldi	r25, 0x96	; 150
    14f0:	11 c0       	rjmp	.+34     	; 0x1514 <__floatsisf+0x6a>
    14f2:	77 23       	and	r23, r23
    14f4:	21 f0       	breq	.+8      	; 0x14fe <__floatsisf+0x54>
    14f6:	9e e8       	ldi	r25, 0x8E	; 142
    14f8:	87 2f       	mov	r24, r23
    14fa:	76 2f       	mov	r23, r22
    14fc:	05 c0       	rjmp	.+10     	; 0x1508 <__floatsisf+0x5e>
    14fe:	66 23       	and	r22, r22
    1500:	71 f0       	breq	.+28     	; 0x151e <__floatsisf+0x74>
    1502:	96 e8       	ldi	r25, 0x86	; 134
    1504:	86 2f       	mov	r24, r22
    1506:	70 e0       	ldi	r23, 0x00	; 0
    1508:	60 e0       	ldi	r22, 0x00	; 0
    150a:	2a f0       	brmi	.+10     	; 0x1516 <__floatsisf+0x6c>
    150c:	9a 95       	dec	r25
    150e:	66 0f       	add	r22, r22
    1510:	77 1f       	adc	r23, r23
    1512:	88 1f       	adc	r24, r24
    1514:	da f7       	brpl	.-10     	; 0x150c <__floatsisf+0x62>
    1516:	88 0f       	add	r24, r24
    1518:	96 95       	lsr	r25
    151a:	87 95       	ror	r24
    151c:	97 f9       	bld	r25, 7
    151e:	08 95       	ret

00001520 <__fp_inf>:
    1520:	97 f9       	bld	r25, 7
    1522:	9f 67       	ori	r25, 0x7F	; 127
    1524:	80 e8       	ldi	r24, 0x80	; 128
    1526:	70 e0       	ldi	r23, 0x00	; 0
    1528:	60 e0       	ldi	r22, 0x00	; 0
    152a:	08 95       	ret

0000152c <__fp_nan>:
    152c:	9f ef       	ldi	r25, 0xFF	; 255
    152e:	80 ec       	ldi	r24, 0xC0	; 192
    1530:	08 95       	ret

00001532 <__fp_pscA>:
    1532:	00 24       	eor	r0, r0
    1534:	0a 94       	dec	r0
    1536:	16 16       	cp	r1, r22
    1538:	17 06       	cpc	r1, r23
    153a:	18 06       	cpc	r1, r24
    153c:	09 06       	cpc	r0, r25
    153e:	08 95       	ret

00001540 <__fp_pscB>:
    1540:	00 24       	eor	r0, r0
    1542:	0a 94       	dec	r0
    1544:	12 16       	cp	r1, r18
    1546:	13 06       	cpc	r1, r19
    1548:	14 06       	cpc	r1, r20
    154a:	05 06       	cpc	r0, r21
    154c:	08 95       	ret

0000154e <__fp_round>:
    154e:	09 2e       	mov	r0, r25
    1550:	03 94       	inc	r0
    1552:	00 0c       	add	r0, r0
    1554:	11 f4       	brne	.+4      	; 0x155a <__fp_round+0xc>
    1556:	88 23       	and	r24, r24
    1558:	52 f0       	brmi	.+20     	; 0x156e <__fp_round+0x20>
    155a:	bb 0f       	add	r27, r27
    155c:	40 f4       	brcc	.+16     	; 0x156e <__fp_round+0x20>
    155e:	bf 2b       	or	r27, r31
    1560:	11 f4       	brne	.+4      	; 0x1566 <__fp_round+0x18>
    1562:	60 ff       	sbrs	r22, 0
    1564:	04 c0       	rjmp	.+8      	; 0x156e <__fp_round+0x20>
    1566:	6f 5f       	subi	r22, 0xFF	; 255
    1568:	7f 4f       	sbci	r23, 0xFF	; 255
    156a:	8f 4f       	sbci	r24, 0xFF	; 255
    156c:	9f 4f       	sbci	r25, 0xFF	; 255
    156e:	08 95       	ret

00001570 <__fp_split3>:
    1570:	57 fd       	sbrc	r21, 7
    1572:	90 58       	subi	r25, 0x80	; 128
    1574:	44 0f       	add	r20, r20
    1576:	55 1f       	adc	r21, r21
    1578:	59 f0       	breq	.+22     	; 0x1590 <__fp_splitA+0x10>
    157a:	5f 3f       	cpi	r21, 0xFF	; 255
    157c:	71 f0       	breq	.+28     	; 0x159a <__fp_splitA+0x1a>
    157e:	47 95       	ror	r20

00001580 <__fp_splitA>:
    1580:	88 0f       	add	r24, r24
    1582:	97 fb       	bst	r25, 7
    1584:	99 1f       	adc	r25, r25
    1586:	61 f0       	breq	.+24     	; 0x15a0 <__fp_splitA+0x20>
    1588:	9f 3f       	cpi	r25, 0xFF	; 255
    158a:	79 f0       	breq	.+30     	; 0x15aa <__fp_splitA+0x2a>
    158c:	87 95       	ror	r24
    158e:	08 95       	ret
    1590:	12 16       	cp	r1, r18
    1592:	13 06       	cpc	r1, r19
    1594:	14 06       	cpc	r1, r20
    1596:	55 1f       	adc	r21, r21
    1598:	f2 cf       	rjmp	.-28     	; 0x157e <__fp_split3+0xe>
    159a:	46 95       	lsr	r20
    159c:	f1 df       	rcall	.-30     	; 0x1580 <__fp_splitA>
    159e:	08 c0       	rjmp	.+16     	; 0x15b0 <__fp_splitA+0x30>
    15a0:	16 16       	cp	r1, r22
    15a2:	17 06       	cpc	r1, r23
    15a4:	18 06       	cpc	r1, r24
    15a6:	99 1f       	adc	r25, r25
    15a8:	f1 cf       	rjmp	.-30     	; 0x158c <__fp_splitA+0xc>
    15aa:	86 95       	lsr	r24
    15ac:	71 05       	cpc	r23, r1
    15ae:	61 05       	cpc	r22, r1
    15b0:	08 94       	sec
    15b2:	08 95       	ret

000015b4 <__fp_zero>:
    15b4:	e8 94       	clt

000015b6 <__fp_szero>:
    15b6:	bb 27       	eor	r27, r27
    15b8:	66 27       	eor	r22, r22
    15ba:	77 27       	eor	r23, r23
    15bc:	cb 01       	movw	r24, r22
    15be:	97 f9       	bld	r25, 7
    15c0:	08 95       	ret

000015c2 <__mulsf3>:
    15c2:	0b d0       	rcall	.+22     	; 0x15da <__mulsf3x>
    15c4:	c4 cf       	rjmp	.-120    	; 0x154e <__fp_round>
    15c6:	b5 df       	rcall	.-150    	; 0x1532 <__fp_pscA>
    15c8:	28 f0       	brcs	.+10     	; 0x15d4 <__mulsf3+0x12>
    15ca:	ba df       	rcall	.-140    	; 0x1540 <__fp_pscB>
    15cc:	18 f0       	brcs	.+6      	; 0x15d4 <__mulsf3+0x12>
    15ce:	95 23       	and	r25, r21
    15d0:	09 f0       	breq	.+2      	; 0x15d4 <__mulsf3+0x12>
    15d2:	a6 cf       	rjmp	.-180    	; 0x1520 <__fp_inf>
    15d4:	ab cf       	rjmp	.-170    	; 0x152c <__fp_nan>
    15d6:	11 24       	eor	r1, r1
    15d8:	ee cf       	rjmp	.-36     	; 0x15b6 <__fp_szero>

000015da <__mulsf3x>:
    15da:	ca df       	rcall	.-108    	; 0x1570 <__fp_split3>
    15dc:	a0 f3       	brcs	.-24     	; 0x15c6 <__mulsf3+0x4>

000015de <__mulsf3_pse>:
    15de:	95 9f       	mul	r25, r21
    15e0:	d1 f3       	breq	.-12     	; 0x15d6 <__mulsf3+0x14>
    15e2:	95 0f       	add	r25, r21
    15e4:	50 e0       	ldi	r21, 0x00	; 0
    15e6:	55 1f       	adc	r21, r21
    15e8:	62 9f       	mul	r22, r18
    15ea:	f0 01       	movw	r30, r0
    15ec:	72 9f       	mul	r23, r18
    15ee:	bb 27       	eor	r27, r27
    15f0:	f0 0d       	add	r31, r0
    15f2:	b1 1d       	adc	r27, r1
    15f4:	63 9f       	mul	r22, r19
    15f6:	aa 27       	eor	r26, r26
    15f8:	f0 0d       	add	r31, r0
    15fa:	b1 1d       	adc	r27, r1
    15fc:	aa 1f       	adc	r26, r26
    15fe:	64 9f       	mul	r22, r20
    1600:	66 27       	eor	r22, r22
    1602:	b0 0d       	add	r27, r0
    1604:	a1 1d       	adc	r26, r1
    1606:	66 1f       	adc	r22, r22
    1608:	82 9f       	mul	r24, r18
    160a:	22 27       	eor	r18, r18
    160c:	b0 0d       	add	r27, r0
    160e:	a1 1d       	adc	r26, r1
    1610:	62 1f       	adc	r22, r18
    1612:	73 9f       	mul	r23, r19
    1614:	b0 0d       	add	r27, r0
    1616:	a1 1d       	adc	r26, r1
    1618:	62 1f       	adc	r22, r18
    161a:	83 9f       	mul	r24, r19
    161c:	a0 0d       	add	r26, r0
    161e:	61 1d       	adc	r22, r1
    1620:	22 1f       	adc	r18, r18
    1622:	74 9f       	mul	r23, r20
    1624:	33 27       	eor	r19, r19
    1626:	a0 0d       	add	r26, r0
    1628:	61 1d       	adc	r22, r1
    162a:	23 1f       	adc	r18, r19
    162c:	84 9f       	mul	r24, r20
    162e:	60 0d       	add	r22, r0
    1630:	21 1d       	adc	r18, r1
    1632:	82 2f       	mov	r24, r18
    1634:	76 2f       	mov	r23, r22
    1636:	6a 2f       	mov	r22, r26
    1638:	11 24       	eor	r1, r1
    163a:	9f 57       	subi	r25, 0x7F	; 127
    163c:	50 40       	sbci	r21, 0x00	; 0
    163e:	8a f0       	brmi	.+34     	; 0x1662 <__mulsf3_pse+0x84>
    1640:	e1 f0       	breq	.+56     	; 0x167a <__mulsf3_pse+0x9c>
    1642:	88 23       	and	r24, r24
    1644:	4a f0       	brmi	.+18     	; 0x1658 <__mulsf3_pse+0x7a>
    1646:	ee 0f       	add	r30, r30
    1648:	ff 1f       	adc	r31, r31
    164a:	bb 1f       	adc	r27, r27
    164c:	66 1f       	adc	r22, r22
    164e:	77 1f       	adc	r23, r23
    1650:	88 1f       	adc	r24, r24
    1652:	91 50       	subi	r25, 0x01	; 1
    1654:	50 40       	sbci	r21, 0x00	; 0
    1656:	a9 f7       	brne	.-22     	; 0x1642 <__mulsf3_pse+0x64>
    1658:	9e 3f       	cpi	r25, 0xFE	; 254
    165a:	51 05       	cpc	r21, r1
    165c:	70 f0       	brcs	.+28     	; 0x167a <__mulsf3_pse+0x9c>
    165e:	60 cf       	rjmp	.-320    	; 0x1520 <__fp_inf>
    1660:	aa cf       	rjmp	.-172    	; 0x15b6 <__fp_szero>
    1662:	5f 3f       	cpi	r21, 0xFF	; 255
    1664:	ec f3       	brlt	.-6      	; 0x1660 <__mulsf3_pse+0x82>
    1666:	98 3e       	cpi	r25, 0xE8	; 232
    1668:	dc f3       	brlt	.-10     	; 0x1660 <__mulsf3_pse+0x82>
    166a:	86 95       	lsr	r24
    166c:	77 95       	ror	r23
    166e:	67 95       	ror	r22
    1670:	b7 95       	ror	r27
    1672:	f7 95       	ror	r31
    1674:	e7 95       	ror	r30
    1676:	9f 5f       	subi	r25, 0xFF	; 255
    1678:	c1 f7       	brne	.-16     	; 0x166a <__mulsf3_pse+0x8c>
    167a:	fe 2b       	or	r31, r30
    167c:	88 0f       	add	r24, r24
    167e:	91 1d       	adc	r25, r1
    1680:	96 95       	lsr	r25
    1682:	87 95       	ror	r24
    1684:	97 f9       	bld	r25, 7
    1686:	08 95       	ret

00001688 <_exit>:
    1688:	f8 94       	cli

0000168a <__stop_program>:
    168a:	ff cf       	rjmp	.-2      	; 0x168a <__stop_program>
